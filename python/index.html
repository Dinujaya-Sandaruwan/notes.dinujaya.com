<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../style.css" />
    <link rel="stylesheet" href="../scrollBar.css" />
    <link rel="stylesheet" href="../animation.css" />
    <script src="https://unpkg.com/ionicons@latest/dist/ionicons.js"></script>
    <title>JavaScript Notes</title>
    <link rel="stylesheet" href="../prism.css" />
    <link rel="stylesheet" href="../page.css" />
  </head>
  <body>
    <nav class="desktopMenu">
      <div class="navList">
        <a href="" class="navLink">
          <div class="navItem">
            <ion-icon class="listIcon" name="home"></ion-icon>Home
          </div></a
        >
        <a href="" class="navLink">
          <div class="navItem">
            <ion-icon name="logo-youtube" class="listIcon"></ion-icon>YT
            Playlist
          </div></a
        >
        <a href="" class="navLink">
          <div class="navItem">
            <ion-icon name="bookmarks" class="listIcon"></ion-icon>BookMarks
          </div></a
        >
        <a href="" class="navLink">
          <div class="navItem">
            <ion-icon name="logo-react" class="listIcon"></ion-icon>Boilerplate
          </div></a
        >
      </div>
      <ion-icon
        name="menu"
        class="burgerMenu"
        onclick="mobileMenuDisplayBlock()"
      ></ion-icon>
      <a href="https://github.com/Dinujaya-Sandaruwan" target="_blank">
        <ion-icon name="logo-github"></ion-icon>
      </a>
    </nav>

    <nav class="mobileMenu" id="mobileMenu">
      <div class="mobileMenuItem">
        <span class="close" onclick="mobileMenuDisplayNone()"
          ><ion-icon name="close" class="closeIcon"></ion-icon
        ></span>
        <a class="navLink" href="">
          <div class="navItemMobile odd">Home</div></a
        >
        <a class="navLink" href="">
          <div class="navItemMobile even">YT Playlist</div></a
        >
        <a class="navLink" href="">
          <div class="navItemMobile odd">BookMarks</div></a
        >
        <a class="navLink" href="">
          <div class="navItemMobile even">Boilerplate</div></a
        >
      </div>
    </nav>

    <h1 class="heading">PYTHON NOTES</h1>

    <!-- Content of this page -->

    <div class="content">
      <h2 class="a-main-topic">01 Getting Started</h2>
      <article>
        <h2>01- What is Python</h2>
        <p
          >Python is a high-level, interpreted programming language that is
          known for its simplicity, readability, and versatility. It was created
          by Guido van Rossum in the late 1980s and released in 1991. Python is
          widely used in web development, data science, artificial intelligence,
          and many other fields.</p
        >
        <p>Here's an example of a simple "Hello, World!" program in Python:</p>
        <pre class="language-python">
<code>print("Hello, World!")</code></pre>
        <p
          >Python code is executed line by line, and the output of the program
          appears in the console. You can also run Python code in interactive
          mode by typing "python" in your terminal or command prompt, which
          opens up a Python interpreter that allows you to enter Python commands
          and see the results immediately.</p
        >
        <p
          >Python has a large standard library and a vast number of third-party
          libraries, which makes it easy to perform many tasks with just a few
          lines of code. It also supports multiple programming paradigms,
          including object-oriented, procedural, and functional programming.</p
        >
      </article>
      <article>
        <h2>02- Installing Python</h2>
        <p
          >Before you can start writing Python code, you need to have Python
          installed on your computer. Here are the steps to install Python:</p
        >
        <ol>
          <li
            >Go to the
            <a href="https://www.python.org/downloads/" target="_blank"
              >Python downloads page</a
            >.</li
          >
          <li
            >Click the "Download" button for the latest version of Python 3 (as
            of May 2023, it's Python 3.10.0).</li
          >
          <li
            >Run the downloaded installer file and follow the instructions to
            install Python on your computer.</li
          >
        </ol>
        <p
          >Once Python is installed, you can verify the installation by opening
          a terminal or command prompt and typing:</p
        >
        <pre class="language-python">
<code>python --version</code></pre>
        <p>This should display the version of Python that you installed.</p>
        <p
          >You can also install Python using a package manager such as
          <a href="https://brew.sh/" target="_blank">Homebrew</a> (on macOS and
          Linux) or
          <a href="https://chocolatey.org/" target="_blank">Chocolatey</a> (on
          Windows). These tools make it easy to install and manage multiple
          versions of Python and any required dependencies.</p
        >
      </article>
      <article>
        <h2>03- Python Interpreter</h2>
        <p
          >The Python interpreter is a command-line tool that allows you to run
          Python code interactively. It's a great way to quickly test code
          snippets or explore the Python language.</p
        >
        <p
          >To start the Python interpreter, open a terminal or command prompt
          and type:</p
        >
        <pre class="language-python">
<code>python</code></pre>
        <p
          >This will start the interpreter and display the Python prompt, which
          looks like this:</p
        >
        <pre class="language-python">
<code>&gt;&gt;&gt;</code></pre>
        <p
          >Now you can type Python code directly into the prompt and see the
          results immediately:</p
        >
        <pre
          class="language-python"
        ><code>&gt;&gt;&gt; print("Hello, World!")<br/>&nbsp;&nbsp;&nbsp;&nbsp;Hello, World!</code></pre>
        <p>You can exit the Python interpreter by typing:</p>
        <pre class="language-python">
<code>exit()</code></pre>
        <p
          >Alternatively, you can use the keyboard shortcut Ctrl-D (on macOS and
          Linux) or Ctrl-Z (on Windows) to exit the interpreter.</p
        >
        <p
          >The Python interpreter also allows you to run Python scripts from the
          command line. To run a script, simply type:</p
        >
        <pre class="language-python">
<code>python path/to/script.py</code></pre>
        <p
          >This will execute the Python code in the script and display any
          output in the console.</p
        >
      </article>
      <article>
        <h2>04- Code Editors</h2>
        <p
          >A code editor is a software tool that allows you to write and edit
          code more efficiently. There are many code editors available for
          Python, ranging from basic text editors to full-featured integrated
          development environments (IDEs).</p
        >
        <p>Here are some popular code editors for Python:</p>
        <ul>
          <li
            ><a href="https://code.visualstudio.com/" target="_blank"
              >Visual Studio Code</a
            >
            - a lightweight, cross-platform code editor with a wide range of
            features and extensions.</li
          >
          <li
            ><a href="https://www.jetbrains.com/pycharm/" target="_blank"
              >PyCharm</a
            >
            - a powerful IDE for Python with advanced features such as code
            analysis, debugging, and refactoring.</li
          >
          <li
            ><a href="https://www.sublimetext.com/" target="_blank"
              >Sublime Text</a
            >
            - a popular text editor with a simple interface and a wide range of
            plugins.</li
          >
          <li
            ><a href="https://www.vim.org/" target="_blank">Vim</a> - a highly
            configurable text editor with advanced features such as macros and
            keyboard shortcuts.</li
          >
        </ul>
        <p
          >Each code editor has its own strengths and weaknesses, so it's
          important to choose the one that best fits your needs and
          preferences.</p
        >
        <p
          >Once you have chosen a code editor, you can use it to create and edit
          Python files. Most code editors offer features such as syntax
          highlighting, code completion, and debugging to help you write code
          more efficiently.</p
        >
        <p
          >When you're ready to run your Python code, you can use the code
          editor to execute the code or switch to a terminal or command prompt
          to run the code using the Python interpreter.</p
        >
      </article>
      <article>
        <h2>05- Your First Python Program</h2>
        <p
          >Writing your first Python program is a great way to get started with
          the language. In this example, we'll create a simple "Hello, World!"
          program:</p
        >
        <pre class="language-python">
<code>print("Hello, World!")</code></pre>
        <p>Here's what the code does:</p>
        <ul>
          <li
            >The <span>print()</span> function is a built-in Python function
            that displays output to the console.</li
          >
          <li
            >The string "Hello, World!" is enclosed in quotes to indicate that
            it is a string literal.</li
          >
        </ul>
        <p
          >To run the program, you can use the Python interpreter or a code
          editor. If you're using the interpreter, simply type the code at the
          prompt and press Enter:</p
        >
        <pre
          class="language-python"
        ><code>&gt;&gt;&gt; print("Hello, World!")<br/>&nbsp;&nbsp;&nbsp;&nbsp;Hello, World!</code></pre>
        <p
          >If you're using a code editor, save the code in a file with a .py
          extension (e.g. hello.py) and run the program using the Python
          interpreter:</p
        >
        <pre class="language-python">
<code>python hello.py</code></pre>
        <p
          >This will execute the code in the file and display the output in the
          console:</p
        >
        <pre class="language-python">
<code>Hello, World!</code></pre>
        <p>Congratulations! You've written your first Python program.</p>
      </article>
      <article>
        <h2>06- Python Extensions for VS Code</h2>
        <p
          >Visual Studio Code (VS Code) is a popular open-source code editor
          that supports many programming languages, including Python. One of the
          great things about VS Code is its vast ecosystem of extensions, which
          can be installed to add new features and functionality to the
          editor.</p
        >
        <p
          >If you're using VS Code for Python development, here are some
          essential extensions that you should consider installing:</p
        >
        <ul>
          <li
            ><a
              href="https://marketplace.visualstudio.com/items?itemName=ms-python.python"
              target="_blank"
              >Python</a
            >
            - an official extension from Microsoft that provides rich Python
            language support, including code completion, debugging, and unit
            testing.</li
          >
          <li
            ><a
              href="https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance"
              target="_blank"
              >Pylance</a
            >
            - a fast and feature-rich language server for Python that provides
            advanced type checking, auto-imports, and code analysis.</li
          >
          <li
            ><a
              href="https://marketplace.visualstudio.com/items?itemName=ms-python.python-docs"
              target="_blank"
              >Python Docstring Generator</a
            >
            - an extension that generates docstrings for Python functions,
            classes, and modules.</li
          >
          <li
            ><a
              href="https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-test-adapter"
              target="_blank"
              >Test Explorer for Python</a
            >
            - an extension that provides a graphical user interface for running
            and debugging Python tests.</li
          >
          <li
            ><a
              href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag"
              target="_blank"
              >Auto Close Tag</a
            >
            - an extension that automatically closes HTML tags, which can be
            useful when working with Flask or Django web frameworks.</li
          >
        </ul>
        <p
          >These extensions can help you write, test, and debug your Python code
          more efficiently and effectively. To install an extension, simply open
          VS Code and click on the Extensions icon on the left-hand side of the
          window. Then search for the extension you want to install and click on
          the Install button.</p
        >
        <p
          >With these extensions installed, you'll have everything you need to
          write high-quality Python code in VS Code.</p
        >
      </article>
      <article>
        <h2>07- Linting Python Code</h2>
        <p
          >Linting is the process of checking your code for syntax errors,
          common mistakes, and potential bugs. In Python, you can use a linter
          to automatically check your code as you write it, helping you catch
          errors before you even run your program.</p
        >
        <p
          >One of the most popular linters for Python is
          <a href="https://flake8.pycqa.org/en/latest/" target="_blank"
            >Flake8</a
          >. It checks your code for syntax errors, style issues, and common
          mistakes using a combination of three other tools:
          <a href="https://pycodestyle.pycqa.org/en/latest/" target="_blank"
            >pycodestyle</a
          >,
          <a href="https://pyflakes.pycqa.org/en/latest/" target="_blank"
            >pyflakes</a
          >, and
          <a href="https://mypy.readthedocs.io/en/stable/" target="_blank"
            >mypy</a
          >.</p
        >
        <p
          >To use Flake8 in VS Code, you'll first need to install it using
          pip:</p
        >
        <pre class="language-python">
<code>pip install flake8</code></pre>
        <p
          >Then, you can install the
          <a
            href="https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance"
            target="_blank"
            >Pylance</a
          >
          extension for VS Code, which provides integration with Flake8. Once
          you have Pylance installed, open your Python file in VS Code and you
          should see linting errors and warnings highlighted in the editor.</p
        >
        <p
          >You can also configure Flake8 to suit your needs by creating a
          <code>.flake8</code> configuration file in your project directory.
          This file allows you to customize the linter's behavior, such as
          ignoring specific errors or changing the line length limit. For more
          information on configuring Flake8, check out the
          <a
            href="https://flake8.pycqa.org/en/latest/user/configuration.html"
            target="_blank"
            >official documentation</a
          >.</p
        >
        <p
          >Linting your code with Flake8 (or another linter) can help you write
          more reliable and readable code, as well as catch errors before they
          cause problems in your program.</p
        >
      </article>
      <article>
        <h2>08- Formatting Python Code (VsCode)</h2>
        <p
          >Consistent code formatting is important for readability and
          maintainability of your codebase. In Python, you can use a code
          formatter to automatically format your code to follow a consistent
          style.</p
        >
        <p
          >One popular code formatter for Python is
          <a href="https://black.readthedocs.io/en/stable/" target="_blank"
            >Black</a
          >. Black is an opinionated formatter that enforces a consistent style,
          which can help reduce debates about formatting style within your
          team.</p
        >
        <p
          >To use Black in VS Code, you'll first need to install it using
          pip:</p
        >
        <pre class="language-python">
<code>pip install black</code></pre>
        <p
          >Then, you can install the
          <a
            href="https://marketplace.visualstudio.com/items?itemName=psf.black"
            target="_blank"
            >Black</a
          >
          extension for VS Code, which provides integration with Black. Once you
          have Black installed, you can format your Python code by using the
          command palette (Ctrl+Shift+P on Windows or Cmd+Shift+P on Mac) and
          searching for "Format Document With...". Choose "Black" from the list
          of available formatters.</p
        >
        <p
          >You can also configure Black to suit your needs by creating a
          <code>pyproject.toml</code> configuration file in your project
          directory. This file allows you to customize Black's behavior, such as
          setting the line length limit or excluding certain files from
          formatting. For more information on configuring Black, check out the
          <a
            href="https://black.readthedocs.io/en/stable/pyproject_toml.html"
            target="_blank"
            >official documentation</a
          >.</p
        >
        <p
          >Using a code formatter like Black can help you maintain consistent
          formatting in your codebase, which can improve readability and make it
          easier for others to contribute to your project.</p
        >
      </article>
      <article>
        <h2>09- Running Python Code</h2>
        <p
          >After you've written some Python code, you'll need to run it to see
          the output. There are a few ways to run Python code, depending on your
          setup and what you're trying to accomplish.</p
        >
        <h3>Running Python Code in the Terminal</h3>
        <p
          >The simplest way to run Python code is to use the Python interpreter
          in your terminal. Open a terminal window and navigate to the directory
          containing your Python file. Then, type the following command:</p
        >
        <pre class="language-python">
<code>python filename.py</code></pre>
        <p
          >Replace <code>filename.py</code> with the name of your Python file.
          This will execute the code in the file and display the output in the
          terminal.</p
        >
        <h3>Running Python Code in an IDE or Text Editor</h3>
        <p
          >If you're using an IDE or text editor like VS Code, you can usually
          run Python code from within the editor. In VS Code, for example, you
          can open a Python file and press F5 to run the code in the debugger.
          You can also use the Run button in the top menu bar to run the
          code.</p
        >
        <h3>Running Python Code Online</h3>
        <p
          >If you don't have Python installed on your computer or you're working
          on a computer that doesn't allow you to install software, you can run
          Python code online using a service like
          <a href="https://www.pythonanywhere.com/" target="_blank"
            >PythonAnywhere</a
          >. These services allow you to run Python code in your browser without
          installing anything on your computer.</p
        >
        <p
          >Regardless of how you choose to run your Python code, make sure
          you're using a reliable source and take appropriate security
          precautions to protect your code and your computer.</p
        >
      </article>
      <article>
        <h2>10- Python Implementations</h2>
        <p
          >Python is an open-source programming language, which means that
          anyone can use, modify, and distribute the code. As a result, there
          are several different implementations of the Python programming
          language, each with its own strengths and weaknesses.</p
        >
        <h3>CPython</h3>
        <p
          >CPython is the reference implementation of the Python programming
          language. It is written in C and is the most widely used
          implementation of Python. CPython is known for its speed and
          stability, and it is the default implementation of Python on most
          Unix-based systems.</p
        >
        <h3>Jython</h3>
        <p
          >Jython is an implementation of Python that is written in Java. It
          allows Python code to be run on the Java Virtual Machine (JVM), which
          can be useful if you need to integrate Python code with existing Java
          code.</p
        >
        <h3>IronPython</h3>
        <p
          >IronPython is an implementation of Python that is written in C# and
          is designed to run on the .NET framework. It allows Python code to be
          run on the .NET runtime, which can be useful if you need to integrate
          Python code with existing .NET code.</p
        >
        <h3>PyPy</h3>
        <p
          >PyPy is an alternative implementation of Python that is known for its
          speed. It uses a Just-in-Time (JIT) compiler to speed up Python code,
          which can make it faster than CPython in some cases. PyPy also
          supports a subset of the Python 3 standard library.</p
        >
        <p
          >These are just a few of the many different implementations of Python
          that are available. Each implementation has its own advantages and
          disadvantages, and the best one for you will depend on your specific
          needs and use case.</p
        >
      </article>
      <article>
        <h2>11- How Python Code is Executed</h2>
        <p
          >When you run a Python program, the Python interpreter reads your code
          and executes it line by line. Here's a high-level overview of how this
          process works:</p
        >
        <ol>
          <li
            >The interpreter reads your code from the top of the file to the
            bottom.</li
          >
          <li
            >As it reads each line, it checks the syntax of the code to make
            sure it is valid Python code.</li
          >
          <li
            >If the syntax is valid, the interpreter executes the code on that
            line. If the syntax is invalid, the interpreter will raise a syntax
            error.</li
          >
          <li
            >If the line of code is a function or class definition, the
            interpreter stores it in memory so it can be used later.</li
          >
          <li
            >Once the interpreter has finished reading and executing all the
            code in your program, it exits.</li
          >
        </ol>
        <p
          >It's worth noting that the Python interpreter doesn't execute your
          code exactly as it appears in the file. Instead, it first compiles
          your code into bytecode, which is a lower-level representation of your
          code that the interpreter can execute more quickly. This compilation
          step happens automatically in the background and is usually not
          something you need to worry about.</p
        >
      </article>
      <article>
        <h2>12- Python Interpreter Types</h2>
        <p
          >There are two main types of Python interpreters: interactive and
          non-interactive.</p
        >
        <h3>Interactive Interpreters</h3>
        <p
          >An interactive interpreter allows you to enter Python code directly
          into the interpreter and see the results immediately. The standard
          Python distribution includes an interactive interpreter called
          <span>python</span>. When you run <span>python</span> without any
          arguments, it starts an interactive interpreter session:</p
        >
        <pre class="language-python">
<code>python</code></pre>
        <p
          >Interactive interpreters can be useful for quickly testing code
          snippets, debugging code, and exploring the Python language. However,
          they are not ideal for writing longer programs, as they don't provide
          features like syntax highlighting or code completion.</p
        >
        <h3>Non-Interactive Interpreters</h3>
        <p
          >A non-interactive interpreter is used to run Python code that is
          stored in a file. When you run a Python script from the command line,
          you are using a non-interactive interpreter. Non-interactive
          interpreters can also be used in automated scripts or in web
          applications.</p
        >
        <p
          >There are several non-interactive Python interpreters available,
          including:</p
        >
        <ul>
          <li><span>python</span>: the standard Python interpreter.</li>
          <li
            ><span>ipython</span>: an enhanced interactive Python interpreter
            that provides additional features like syntax highlighting, tab
            completion, and object introspection.</li
          >
          <li
            ><span>jupyter</span>: a web-based interactive Python environment
            that allows you to create and share documents that contain live
            code, equations, visualizations, and narrative text.</li
          >
        </ul>
      </article>
      <h2 class="a-main-topic">02 Primitive Types</h2>
      <article>
        <h2>01 - Variables</h2>
        <p
          >In Python, variables are used to store data values. A variable is
          created when a value is assigned to it using the assignment operator
          (=).</p
        >
        <p>There are different types of variables in Python:</p>
        <ol>
          <li
            ><strong>Numeric:</strong> Used to store numbers. There are three
            types of numeric variables: integers (int), floating-point numbers
            (float), and complex numbers (complex).</li
          >
          <li
            ><strong>Boolean:</strong> Used to store values of True or
            False.</li
          >
          <li
            ><strong>String:</strong> Used to store a sequence of
            characters.</li
          >
        </ol>
        <p>Here are some examples of creating and using variables:</p>
        <pre class="language-python">

      <code>x = 5
      y = 3.14
      z = 2 + 3j
      a = True
      b = "Hello, world!"
      print(x)
      print(y)
      print(z)
      print(a)
      print(b)</code>
      </pre>

        <p
          >In the above example, we created five variables, each with a
          different data type. We then printed the value of each variable using
          the print() function.</p
        >
        <p>Output:</p>
        <pre><span>5</span>
      <span>3.14</span>
      <span>(2+3j)</span>
      <span>True</span>
      <span>Hello, world!</span></pre>
      </article>
      <article>
        <h2>02 - Variable Names</h2>
        <p
          >When creating variables in Python, there are some rules and
          conventions for naming them:</p
        >
        <ul>
          <li
            >Variable names can contain letters (a-z, A-Z), numbers (0-9), and
            underscores (_).</li
          >
          <li
            >Variable names must start with a letter or underscore, not a
            number.</li
          >
          <li
            >Variable names are case-sensitive (e.g. 'myVar' and 'myvar' are
            different variables).</li
          >
          <li
            >It's best to use descriptive names for variables that explain what
            they represent (e.g. 'name' instead of 'n').</li
          >
          <li
            >Avoid using reserved words (such as 'if', 'while', 'and', 'or',
            etc.) as variable names.</li
          >
        </ul>
        <p>Here are some examples of valid and invalid variable names:</p>
        <pre class="language-python">

      <code># Valid variable names
      my_var = "valid"
      myVar = "valid"
      myvar1 = "valid"
      _my_var = "valid"

      #Invalid variable names
      
      1myvar = "invalid" # Cannot start with a number
      my-var = "invalid" # Cannot contain hyphens
      my var = "invalid" # Cannot contain spaces
      if = "invalid" # Cannot use reserved words</code>
      </pre>

        <p
          >It's important to follow these naming conventions to make your code
          more readable and easier to understand for yourself and others who may
          work with your code.</p
        >
      </article>
      <article>
        <h2>03 - Strings</h2>
        <p
          >In Python, a string is a sequence of characters, enclosed in either
          single quotes (' ') or double quotes (" ").</p
        >
        <p>Here are some examples of creating and using strings:</p>
        <pre class="language-python">

      <code>name = "Alice"
      message = 'Hello, world!'
      print(name)
      print(message)
      print("My name is " + name) # Concatenation using the + operator</code>
      </pre>

        <p>Output:</p>
        <pre><span>Alice</span>
      <span>Hello, world!</span>
      <span>My name is Alice</span></pre>
        <p
          >You can also access individual characters in a string using
          indexing:</p
        >
        <pre class="language-python">

      <code>message = "Hello"
      print(message[0]) # Output: H
      print(message[-1]) # Output: o</code>
        </pre>
        <p
          >In addition to indexing, there are many built-in string methods in
          Python that you can use to manipulate strings:</p
        >
        <pre class="language-python">

      <code>message = "hello, world"
      print(message.upper()) # Output: HELLO, WORLD
      print(message.capitalize()) # Output: Hello, world
      print(message.replace("o", "i")) # Output: helli, wirld</code>
        </pre>
        <p
          >These are just a few examples of what you can do with strings in
          Python. Strings are a versatile and important data type in
          programming, used for storing and manipulating text and other
          character data.</p
        >
      </article>
      <article>
        <h2>04 - Escape Sequences</h2>
        <p
          >Escape sequences are special characters in strings that allow you to
          include characters that are not normally allowed, such as newlines or
          tabs.</p
        >
        <p>Here are some common escape sequences in Python:</p>
        <pre class="language-python">

      <code>message = "Hello\nworld!"
      print(message) # Output: Hello
                    #         world!
      message = "Hello\tworld!"
      print(message) # Output: Hello world!</code>
      </pre>

        <p
          >In addition to newlines (\n) and tabs (\t), there are many other
          escape sequences you can use, such as:</p
        >
        <ul>
          <li>\': single quote</li>
          <li>\\: backslash</li>
          <li>\": double quote</li>
        </ul>
        <p>Here are some examples:</p>
        <pre class="language-python">

      <code>message = 'I\'m learning Python!'
      print(message) # Output: I'm learning Python!
      message = "C:\Users\Alice\Documents"
      print(message) # Output: C:\Users\Alice\Documents
      
      message = "He said, "Hello!""
      print(message) # Output: He said, "Hello!"</code>
      </pre>

        <p
          >Escape sequences are useful for formatting text and creating readable
          output in your programs.</p
        >
      </article>
      <article>
        <h2>05 - Formatted Strings</h2>
        <p
          >Formatted strings are a convenient way to insert variables and
          expressions into strings in Python.</p
        >
        <p>Here's an example:</p>
        <pre class="language-python">

      <code>name = "Alice"
      age = 25
      print(f"My name is {name} and I'm {age} years old.") # Output: My name is Alice and I'm 25 years old.</code>
        </pre>
        <p
          >Formatted strings start with an "f" before the opening quote, and
          variables or expressions can be enclosed in curly braces within the
          string.</p
        >
        <p
          >You can also format numbers and specify the number of decimal
          places:</p
        >
        <pre class="language-python">

      <code>pi = 3.141592653589793
      print(f"Pi is approximately {pi:.2f}") # Output: Pi is approximately 3.14</code>
        </pre>
        <p
          >In this example, the ".2f" specifies that the number should be
          formatted with two decimal places.</p
        >
        <p
          >Formatted strings are a powerful tool for generating dynamic output
          in your programs.</p
        >
      </article>
      <article>
        <h2>06 - String Methods</h2>
        <p
          >String methods are built-in functions that operate on strings in
          Python.</p
        >
        <p>Here are some common string methods:</p>
        <ul>
          <li><code>upper()</code>: returns the string in all uppercase</li>
          <li><code>lower()</code>: returns the string in all lowercase</li>
          <li
            ><code>capitalize()</code>: capitalizes the first letter of the
            string</li
          >
          <li
            ><code>title()</code>: capitalizes the first letter of each word in
            the string</li
          >
          <li
            ><code>strip()</code>: removes leading and trailing whitespace from
            the string</li
          >
          <li
            ><code>replace(old, new)</code>: replaces all occurrences of
            <code>old</code> with <code>new</code> in the string</li
          >
          <li
            ><code>split()</code>: splits the string into a list of substrings
            based on a specified delimiter</li
          >
        </ul>
        <p>Here's an example that uses some of these methods:</p>
        <pre class="language-python">

      <code>message = "   hello, world!   "
      print(message.upper()) # Output: "   HELLO, WORLD!   "
      print(message.strip().capitalize()) # Output: "Hello, world!"
      print(message.replace("world", "Python")) # Output: "   hello, Python!   "
      words = message.strip().split(", ")
      print(words) # Output: ['hello', 'world!']</code>
      </pre>

        <p
          >String methods can be chained together to perform multiple operations
          on a string in a single line of code.</p
        >
        <p
          >String methods are a powerful tool for manipulating and processing
          text data in your programs.</p
        >
      </article>
      <article>
        <h2>07 - Numbers</h2>
        <p>Python has several built-in numeric types:</p>
        <ul>
          <li><code>int</code>: integers (whole numbers)</li>
          <li
            ><code>float</code>: floating-point numbers (numbers with a decimal
            point)</li
          >
          <li
            ><code>complex</code>: complex numbers (numbers with a real and
            imaginary part)</li
          >
        </ul>
        <p>Here are some examples of how to use numeric types in Python:</p>
        <pre class="language-python">

      <code>x = 42 # int
      y = 3.14 # float
      z = 2 + 3j # complex
      print(type(x)) # Output: <class 'int'>
      print(type(y)) # Output: <class 'float'>
      print(type(z)) # Output: <class 'complex'>
      
      a = x + y # float
      b = y + z # complex
      c = x * z # complex
      
      print(type(a)) # Output: <class 'float'>
      print(type(b)) # Output: <class 'complex'>
      print(type(c)) # Output: <class 'complex'></code>
      </pre>

        <p
          >Python also provides a number of built-in mathematical functions,
          such as <code>abs()</code> (absolute value),
          <code>round()</code> (round to the nearest integer),
          <code>pow()</code> (exponentiation), and <code>sqrt()</code> (square
          root).</p
        >
        <p
          >You can also perform arithmetic operations on numeric types, such as
          addition, subtraction, multiplication, and division.</p
        >
        <pre class="language-python">

      <code>x = 10
      y = 3
      print(x + y) # Output: 13
      print(x - y) # Output: 7
      print(x * y) # Output: 30
      print(x / y) # Output: 3.3333333333333335
      print(x // y) # Output: 3 (floor division)
      print(x % y) # Output: 1 (modulus)</code>
        </pre>
        <p
          >Numbers are a fundamental data type in Python and are used
          extensively in mathematical and scientific applications.</p
        >
      </article>
      <article>
        <h2>08 - Working with Numbers</h2>
        <p
          >Python provides a number of built-in mathematical functions and
          operators for working with numeric types.</p
        >
        <h3>Mathematical Operators</h3>
        <p
          >The following mathematical operators can be used with numeric types
          in Python:</p
        >
        <ul>
          <li><code>+</code>: addition</li>
          <li><code>-</code>: subtraction</li>
          <li><code>*</code>: multiplication</li>
          <li><code>/</code>: division</li>
          <li
            ><code>//</code>: floor division (round down to nearest integer)</li
          >
          <li><code>%</code>: modulus (remainder after division)</li>
          <li><code>**</code>: exponentiation</li>
        </ul>
        <p>Here are some examples:</p>
        <pre class="language-python">

      <code>x = 10
      y = 3
      print(x + y) # Output: 13
      print(x - y) # Output: 7
      print(x * y) # Output: 30
      print(x / y) # Output: 3.3333333333333335
      print(x // y) # Output: 3
      print(x % y) # Output: 1
      print(x ** y) # Output: 1000</code>
      </pre>

        <h3>Built-in Functions</h3>
        <p
          >Python also provides a number of built-in mathematical functions that
          can be used with numeric types, such as:</p
        >
        <ul>
          <li><code>abs()</code>: absolute value</li>
          <li><code>round()</code>: round to the nearest integer</li>
          <li><code>pow()</code>: exponentiation</li>
          <li><code>sqrt()</code>: square root</li>
        </ul>
        <p>Here are some examples:</p>
        <pre class="language-python">

      <code>x = -10.5
      y = 3.7
      print(abs(x)) # Output: 10.5
      print(round(y)) # Output: 4
      print(pow(2, 3)) # Output: 8
      print(sqrt(16)) # Output: 4.0</code>
      </pre>

        <p
          >Python also provides the <code>math</code> module, which contains a
          wide variety of mathematical functions. To use functions from the
          <code>math</code> module, you must first import it:</p
        >
        <pre class="language-python">

      <code>import math
      x = 2.5
      
      print(math.ceil(x)) # Output: 3 (round up to nearest integer)
      print(math.floor(x)) # Output: 2 (round down to nearest integer)
      print(math.sin(x)) # Output: 0.5984721441039564</code>
      </pre>

        <p
          >Working with numbers is a fundamental part of programming, and Python
          provides many tools for doing so effectively.</p
        >
      </article>
      <article>
        <h2>09 - Type Conversion</h2>
        <p
          >Python provides several built-in functions for converting values from
          one type to another. These functions can be useful when working with
          different types of data or when performing calculations that require
          different types.</p
        >
        <h3>int()</h3>
        <p
          >The <code>int()</code> function can be used to convert a string or
          float to an integer:</p
        >
        <pre class="language-python">

      <code>x = "123"
      y = 3.14
      print(int(x)) # Output: 123
      print(int(y)) # Output: 3</code>
      </pre>

        <p
          >If the input value cannot be converted to an integer, a
          <code>ValueError</code> will be raised:</p
        >
        <pre class="language-python">

          <code>x = "hello"
      print(int(x)) # Output: ValueError: invalid literal for int() with base 10: 'hello'</code>
      </pre>

        <h3>float()</h3>
        <p
          >The <code>float()</code> function can be used to convert a string or
          integer to a float:</p
        >
        <pre class="language-python">

      <code>x = "3.14"
      y = 123
      print(float(x)) # Output: 3.14
      print(float(y)) # Output: 123.0</code>
      </pre>

        <p
          >If the input value cannot be converted to a float, a
          <code>ValueError</code> will be raised:</p
        >
        <pre class="language-python">

          <code>x = "hello"
      print(float(x)) # Output: ValueError: could not convert string to float: 'hello'</code>
      </pre>

        <h3>str()</h3>
        <p
          >The <code>str()</code> function can be used to convert a value to a
          string:</p
        >
        <pre class="language-python">

      <code>x = 123
      y = 3.14
      print(str(x)) # Output: "123"
      print(str(y)) # Output: "3.14"</code>
      </pre>

        <h3>bool()</h3>
        <p
          >The <code>bool()</code> function can be used to convert a value to a
          boolean:</p
        >
        <pre class="language-python">

      <code>x = ""
      y = 0
      z = []
      print(bool(x)) # Output: False
      print(bool(y)) # Output: False
      print(bool(z)) # Output: False</code>
      </pre>

        <p
          >In general, any value that is considered "empty" or "zero" will be
          converted to <code>False</code>, and any other value will be converted
          to <code>True</code>.</p
        >
        <p
          >Using these type conversion functions can be very useful when working
          with data of different types or when performing calculations that
          require different types. However, it's important to be aware of
          potential issues with type conversion, such as losing precision or
          encountering unexpected errors.</p
        >
      </article>
      <h2 class="a-main-topic">03 Control Flow</h2>
      <article>
        <h2>01- Comparison Operators</h2>
        <p
          >In Python, comparison operators are used to compare two values and
          return a Boolean value (True or False) based on the comparison
          result.</p
        >
        <p>The following are the comparison operators available in Python:</p>
        <ul>
          <li>Equal to: ==</li>
          <li>Not equal to: !=</li>
          <li>Greater than: &gt;</li>
          <li>Less than: &lt;</li>
          <li>Greater than or equal to: &gt;=</li>
          <li>Less than or equal to: &lt;=</li>
        </ul>
        <p>Here are some examples:</p>
        <pre class="language-python">

    <code>x = 5
    y = 10
    print(x == y) # Output: False
    print(x != y) # Output: True
    print(x > y) # Output: False
    print(x < y) # Output: True
    print(x >= y) # Output: False
    print(x <= y) # Output: True</code></pre>
        <p
          >Note that the result of a comparison operation is always a Boolean
          value: True or False.</p
        >
      </article>
      <article>
        <h2>02- Conditional Statements</h2>
        <p
          >In Python, conditional statements are used to execute different code
          blocks based on different conditions. The two main types of
          conditional statements are if statements and if-else statements.</p
        >
        <p
          ><strong>If statements:</strong> If statements are used to execute a
          code block if a certain condition is true. Here is an example:</p
        >
        <pre class="language-python">

    <code>x = 5
    if x &gt; 0:
        print("x is positive")</code></pre>
        <p
          >In this example, the code block inside the if statement will only be
          executed if x is greater than 0.</p
        >
        <p
          ><strong>If-else statements:</strong> If-else statements are used to
          execute one code block if a condition is true, and another code block
          if the condition is false. Here is an example:</p
        >
        <pre class="language-python">

    <code>x = -5
    if x &gt; 0:
        print("x is positive")
    else:
        print("x is negative or zero")</code></pre>
        <p
          >In this example, if x is greater than 0, the first code block will be
          executed, otherwise the second code block will be executed.</p
        >
        <p
          ><strong>Elif statements:</strong> Elif statements are used to check
          multiple conditions. Here is an example:</p
        >
        <pre class="language-python">

    <code>x = 0
    if x &gt; 0:
        print("x is positive")
    elif x &lt; 0:
        print("x is negative")
    else:
        print("x is zero")</code></pre>
        <p
          >In this example, the first condition is checked. If it is true, the
          first code block is executed. If it is false, the second condition is
          checked. If it is true, the second code block is executed. Otherwise,
          the third code block is executed.</p
        >
      </article>
      <article>
        <h2>03- Ternary Operator</h2>
        <p
          >In Python, the ternary operator is a shorthand way of writing an
          if-else statement in a single line of code. The syntax of the ternary
          operator is as follows:</p
        >
        <pre
          class="language-python"
        ><code>value_if_true if condition else value_if_false</code></pre>
        <p>Here is an example:</p>
        <pre class="language-python">

    <code>x = 5
    y = 10
    max_value = x if x &gt; y else y
    print(max_value)</code></pre>
        <p
          >In this example, if x is greater than y, max_value will be set to x,
          otherwise max_value will be set to y.</p
        >
        <p
          >While the ternary operator can be useful for writing concise code, it
          can also make the code harder to read if the condition and values are
          complex. In such cases, it may be better to use an if-else statement
          instead.</p
        >
      </article>
      <article>
        <h2>04- Logical Operators</h2>
        <p
          >In Python, logical operators are used to combine conditional
          statements and return a Boolean value (True or False) based on the
          result of the combination. The three main logical operators in Python
          are <code>and</code>, <code>or</code>, and <code>not</code>.</p
        >
        <ul>
          <li
            ><code>and</code>: Returns True if both conditions are True.
            Otherwise, returns False.</li
          >
          <li
            ><code>or</code>: Returns True if at least one of the conditions is
            True. Otherwise, returns False.</li
          >
          <li
            ><code>not</code>: Returns the opposite of the condition (True
            becomes False, and False becomes True).</li
          >
        </ul>
        <p>Here are some examples:</p>
        <pre class="language-python">

    <code>x = 5
    y = 10
    z = 15
    print(x &lt; y and y &lt; z) # Output: True
    print(x &lt; y or y &gt; z) # Output: True
    print(not x &gt; y) # Output: True</code></pre>
        <p
          >Logical operators can be used to combine any number of conditional
          statements to create more complex conditions.</p
        >
      </article>
      <article>
        <h2>05- Short-circuit Evaluation</h2>
        <p
          >In Python, short-circuit evaluation is a behavior of the logical
          operators <code>and</code> and <code>or</code>, in which the second
          operand is evaluated only if necessary.</p
        >
        <p
          >If the left operand of <code>and</code> is False, then the right
          operand will not be evaluated, since the result of the expression will
          always be False. Similarly, if the left operand of <code>or</code> is
          True, then the right operand will not be evaluated, since the result
          of the expression will always be True.</p
        >
        <p>Here are some examples:</p>
        <pre class="language-python">

    <code>x = 5
    y = 10
    z = None
    result = x and y and z
    print(result) # Output: None
    result = x or y or z
    print(result) # Output: 5</code></pre>
        <p
          >In the first example, since z is None (which is equivalent to False),
          the value of <code>x and y and z</code> will be False, and z will not
          be evaluated. Therefore, the result is None.</p
        >
        <p
          >In the second example, since x is non-zero (which is equivalent to
          True), the value of <code>x or y or z</code> will be True, and y and z
          will not be evaluated. Therefore, the result is 5.</p
        >
        <p
          >Short-circuit evaluation can be useful for improving performance and
          avoiding errors that could occur if an unnecessary operation were
          performed.</p
        >
      </article>
      <article>
        <h2>06- Chaining Comparison Operators</h2>
        <p
          >In Python, comparison operators can be chained together to create
          more complex conditions. This allows you to check if a variable is
          within a range or if it matches multiple conditions.</p
        >
        <p>Here's an example:</p>
        <pre class="language-python">

    <code>x = 5
    if 1 &lt; x &lt; 10:
        print("x is between 1 and 10")</code></pre>
        <p
          >In this example, the <code>if</code> statement checks if
          <code>x</code> is greater than 1 <em>and</em> less than 10. If this
          condition is true, then the message "x is between 1 and 10" will be
          printed.</p
        >
        <p
          >You can also use the <code>not</code> operator to invert the result
          of the comparison:</p
        >
        <pre class="language-python">

    <code>x = 5
    if not (x &lt; 1 or x &gt; 10):
        print("x is between 1 and 10")</code></pre>
        <p
          >This code is equivalent to the previous example, but it uses the
          <code>not</code> operator to invert the condition. The parentheses are
          used to group the two comparison operators together.</p
        >
        <p
          >Chaining comparison operators can make your code more concise and
          easier to read.</p
        >
      </article>
      <article>
        <h2>08- For Loops</h2>
        <p
          >In Python, a <code>for</code> loop is used to iterate over a sequence
          (such as a list, tuple, or string) or other iterable object (such as a
          dictionary or file).</p
        >
        <p
          >Here's an example of a <code>for</code> loop that iterates over a
          list:</p
        >
        <pre
          class="language-python"
        ><code>fruits = ["apple", "banana", "cherry"]
    for fruit in fruits:
        print(fruit)</code></pre>
        <p
          >This code will iterate over each element in the list and print it to
          the console.</p
        >
        <p
          >You can also use the <code>range()</code> function to generate a
          sequence of numbers to iterate over:</p
        >
        <pre class="language-python">
<code>for i in range(5):
        print(i)</code></pre>
        <p
          >This code will print the numbers 0 to 4 (inclusive) to the
          console.</p
        >
        <p
          >In addition to iterating over sequences and ranges, you can use a
          <code>for</code> loop to iterate over the keys and values in a
          dictionary:</p
        >
        <pre
          class="language-python"
        ><code>ages = {"Alice": 25, "Bob": 30, "Charlie": 35}
    for name, age in ages.items():
        print(name, age)</code></pre>
        <p
          >This code will iterate over each key-value pair in the dictionary and
          print it to the console.</p
        >
        <p
          >The <code>for</code> loop is a powerful tool for iterating over
          collections of data and performing operations on each element.</p
        >
      </article>
      <article>
        <h2>09- For..Else</h2>
        <p
          >In Python, a <code>for</code> loop can also have an
          <code>else</code> clause that is executed when the loop completes
          normally (i.e., without encountering a
          <code>break</code> statement).</p
        >
        <p>Here's an example:</p>
        <pre
          class="language-python"
        ><code>fruits = ["apple", "banana", "cherry"]
    for fruit in fruits:
        if fruit == "orange":
            break
    else:
        print("I did not find any oranges")</code></pre>
        <p
          >In this code, the <code>for</code> loop iterates over each element in
          the list until it finds the string "orange". If the loop completes
          without finding an orange, then the <code>else</code> clause is
          executed and the message "I did not find any oranges" is printed.</p
        >
        <p
          >You can use the <code>for..else</code> construct to simplify your
          code and make it more readable.</p
        >
      </article>
      <article>
        <h2>10- Nested Loops</h2>
        <p
          >In Python, you can use nested loops to iterate over multiple
          sequences or ranges.</p
        >
        <p>Here's an example:</p>
        <pre class="language-python">
<code>for i in range(3):
        for j in range(2):
            print(f"({i}, {j})")</code></pre>
        <p
          >This code will iterate over the numbers 0, 1, and 2 (inclusive) in
          the outer loop, and the numbers 0 and 1 (inclusive) in the inner loop.
          For each pair of numbers, it will print a tuple containing the values
          of i and j.</p
        >
        <p
          >You can also use nested loops to iterate over the keys and values in
          a dictionary of dictionaries:</p
        >
        <pre class="language-python">
<code>students = {
        "Alice": {"math": 90, "science": 85},
        "Bob": {"math": 80, "science": 95},
        "Charlie": {"math": 95, "science": 90}
    }
    for name, scores in students.items():
        print(name)
        for subject, score in scores.items():
            print(f"  {subject}: {score}")</code></pre>
        <p
          >This code will iterate over each key-value pair in the outer
          dictionary (which contains the names and scores of each student), and
          then iterate over each key-value pair in the inner dictionary (which
          contains the subject names and scores for each student). For each
          student and subject, it will print the name, subject, and score to the
          console.</p
        >
        <p
          >Nested loops can be a powerful tool for iterating over complex data
          structures and performing operations on each element.</p
        >
      </article>
      <article>
        <h2>11- Iterables</h2>
        <p
          >In Python, an iterable is any object that can be used in a
          <code>for</code> loop.</p
        >
        <p
          >Common examples of iterables include lists, tuples, sets, and
          strings:</p
        >
        <pre class="language-python">
<code>my_list = [1, 2, 3, 4, 5]
    my_tuple = ("apple", "banana", "cherry")
    my_set = {1, 2, 3}
    my_string = "hello"</code></pre>
        <p
          >You can also create your own iterables using classes that implement
          the <code>__iter__</code> method and optionally the
          <code>__next__</code> method (for Python 2, you would use the
          <code>next</code> method instead of <code>__next__</code>). The
          <code>__iter__</code> method should return an iterator object, which
          has a <code>__next__</code> method that returns the next value in the
          sequence:</p
        >
        <pre class="language-python">
<code>class MyIterable:
        def __init__(self):
            self.data = [1, 2, 3]
            self.index = 0
            def __iter__(self):
        return self

def __next__(self):
    if self.index &lt; len(self.data):
        value = self.data[self.index]
        self.index += 1
        return value
    else:
        raise StopIteration
        my_iterable = MyIterable()
        for value in my_iterable:
        print(value)</code></pre>
        <p
          >In this code, the <code>MyIterable</code> class defines an iterable
          that returns the values 1, 2, and 3. The <code>iter</code> method
          returns the iterator object itself, and the <code>next</code> method
          returns the next value in the sequence until it reaches the end of the
          data array.</p
        >
        <p
          >Using iterables and iterators can help you write more flexible and
          reusable code, and can also improve performance in some cases.</p
        >
      </article>
      <article>
        <h2>12- While Loops</h2>
        <p
          >A <code>while</code> loop in Python repeatedly executes a block of
          code as long as a specified condition is true.</p
        >
        <p>Here's an example:</p>
        <pre class="language-python">

    <code>x = 0
    while x &lt; 5:
        print(x)
        x += 1</code></pre>
        <p
          >This code prints the values 0, 1, 2, 3, and 4, since the loop
          executes as long as <code>x</code> is less than 5. The
          <code>x += 1</code> statement increments <code>x</code> by 1 in each
          iteration, so that the loop will eventually terminate.</p
        >
        <p
          >You can also use the <code>break</code> statement to exit a while
          loop prematurely:</p
        >
        <pre class="language-python">

    <code>x = 0
    while True:
        if x == 5:
            break
        print(x)
        x += 1</code></pre>
        <p
          >This code does the same thing as the previous example, but uses an
          infinite loop with a <code>break</code> statement inside to terminate
          the loop when <code>x</code> reaches 5.</p
        >
        <p
          >Another statement you can use in a while loop is
          <code>continue</code>, which skips the rest of the current iteration
          and moves on to the next one:</p
        >
        <pre class="language-python">

    <code>x = 0
    while x &lt; 10:
        x += 1
        if x % 2 == 0:
            continue
        print(x)</code></pre>
        <p
          >This code prints the odd numbers between 1 and 10, skipping the even
          ones using the <code>continue</code> statement.</p
        >
        <p
          >While loops can be useful for iterating over a sequence of unknown
          length or for implementing certain types of algorithms that require a
          loop with a variable stopping condition.</p
        >
      </article>
      <article>
        <h2>13- Infinite Loops</h2>
        <p
          >An infinite loop is a loop that never terminates. In Python, you can
          create an infinite loop using a <code>while</code> loop with a
          condition that is always true:</p
        >
        <pre class="language-python">

        <code>while True:
          print("This loop will run forever!")</code></pre>
        <p
          >Since the condition <code>True</code> is always true, this loop will
          run indefinitely, printing the same message over and over again.</p
        >
        <p
          >Infinite loops are generally not desirable, since they can cause your
          program to hang or crash. However, there are some cases where they may
          be useful, such as when you want to keep a program running until the
          user explicitly exits it:</p
        >
        <pre class="language-python">

        <code>while True:
          user_input = input("Enter a command (or 'exit' to quit): ")
          if user_input == "exit":
              break
        # process the user's command...</code></pre>
        <p
          >In this example, the loop keeps running until the user enters the
          command "exit", at which point the loop terminates using the
          <code>break</code> statement.</p
        >
        <p
          >When creating an infinite loop, it's important to ensure that there
          is a way to exit the loop, either by using a
          <code>break</code> statement or by raising an exception. Otherwise,
          your program may become stuck in an infinite loop and never
          terminate.</p
        >
      </article>
      <h2 class="a-main-topic">04 Functions</h2>
      <article>
        <h2>01- Defining Functions</h2>
        <p
          >In Python, functions are blocks of code that can be called to perform
          a specific task. Defining a function allows you to reuse the code
          throughout your program without duplicating it. To define a function
          in Python, you start with the keyword 'def', followed by the function
          name, and the function parameters in parentheses. The code inside the
          function is indented and executed only when the function is called.</p
        >
        <pre class="language-python">

        <code>def greet(name):
            print(f"Hello, {name}!")</code></pre>
        <p
          >The above code defines a function named 'greet' that takes one
          parameter 'name'. When the function is called with an argument, it
          will print out a greeting message with the provided name.</p
        >
        <pre class="language-python">
<code>greet("John")
        greet("Sarah")</code></pre>
        <p
          >The above code calls the 'greet' function twice with different names
          as arguments. When executed, the output will be:</p
        >
        <pre><span>Hello, John!</span>
        <span>Hello, Sarah!</span></pre>
        <p
          >Functions can also have a return statement to return a value after
          the function is called.</p
        >
        <pre class="language-python">
<code>def add(x, y):
            return x + y</code></pre>
        <p
          >The above code defines a function named 'add' that takes two
          parameters 'x' and 'y'. When the function is called with two numbers
          as arguments, it will return the sum of these two numbers.</p
        >
        <pre class="language-python">
<code>result = add(3, 5)
        print(result)</code></pre>
        <p
          >The above code calls the 'add' function with two numbers as arguments
          and assigns the result to the 'result' variable. When executed, the
          output will be:</p
        >
        <pre><span>8</span></pre>
      </article>
      <article>
        <h2>02- Arguments</h2>
        <p
          >When defining a function in Python, you can specify one or more
          parameters, which are variables that the function expects to be passed
          in when it is called. These parameters are also referred to as
          function arguments.</p
        >
        <p
          >There are two types of arguments in Python: positional arguments and
          keyword arguments.</p
        >
        <h3>Positional Arguments</h3>
        <p
          >Positional arguments are the most common type of function argument in
          Python. They are passed to the function in the order in which they are
          defined in the function's parameter list. For example:</p
        >
        <pre class="language-python">

        <code>def multiply(x, y):
            return x * y
        result = multiply(3, 5)
        print(result)</code></pre>

        <p
          >The above code defines a function named 'multiply' that takes two
          positional arguments 'x' and 'y'. When the function is called with two
          numbers as arguments, it will return the product of these two numbers.
          In this case, the function is called with 3 as 'x' and 5 as 'y', and
          the result is assigned to the 'result' variable. When executed, the
          output will be:</p
        >
        <pre><span>15</span></pre>
        <h3>Keyword Arguments</h3>
        <p
          >Keyword arguments are passed to the function using their parameter
          names, as opposed to their position in the parameter list. This allows
          you to specify arguments in any order and only pass the arguments that
          are necessary. For example:</p
        >
        <pre class="language-python">
<code>def divide(dividend, divisor):
            return dividend / divisor
        result = divide(dividend=10, divisor=2)
        print(result)</code></pre>

        <p
          >The above code defines a function named 'divide' that takes two
          keyword arguments 'dividend' and 'divisor'. When the function is
          called with two numbers as arguments, it will return the quotient of
          these two numbers. In this case, the function is called with 10 as
          'dividend' and 2 as 'divisor', and the result is assigned to the
          'result' variable. When executed, the output will be:</p
        >
        <pre><span>5.0</span></pre>
      </article>
      <article>
        <h2>03- Types of Functions</h2>
        <p
          >There are different types of functions in Python, each designed for a
          specific purpose. Here are some of the most commonly used types:</p
        >
        <h3>Built-in Functions</h3>
        <p
          >Python provides a number of built-in functions that can be used
          without needing to define them first. Examples include 'print', 'len',
          'sum', 'max', and 'min', among many others. These functions are part
          of the Python language and are always available for use.</p
        >
        <pre class="language-python">
  <code>print("Hello, World!")
        numbers = [1, 2, 3, 4, 5]
        print(len(numbers))
        print(sum(numbers))
        print(max(numbers))
        print(min(numbers))</code></pre>
        <p
          >The above code demonstrates some of the built-in functions in Python.
          The 'print' function is used to display a message to the console,
          while 'len', 'sum', 'max', and 'min' are used to perform mathematical
          operations on a list of numbers.</p
        >
        <h3>User-Defined Functions</h3>
        <p
          >User-defined functions are functions that you create yourself to
          perform a specific task. These functions are defined using the 'def'
          keyword, followed by the function name, and the function parameters in
          parentheses. You can then write the code that the function will
          execute when it is called.</p
        >
        <pre class="language-python">
<code>def greet(name):
            print(f"Hello, {name}!")
        greet("John")
        greet("Sarah")</code></pre>

        <p
          >The above code defines a user-defined function named 'greet' that
          takes one parameter 'name'. When the function is called with an
          argument, it will print out a greeting message with the provided
          name.</p
        >
        <h3>Anonymous Functions</h3>
        <p
          >Anonymous functions, also known as lambda functions, are small,
          one-line functions that do not have a name. They are often used when
          you need to perform a simple operation on a value, such as squaring a
          number or filtering a list.</p
        >
        <pre class="language-python">
<code>square = lambda x: x ** 2
        result = square(3)
        print(result)</code></pre>

        <p
          >The above code defines an anonymous function that squares a number,
          and assigns it to the 'square' variable. The function is then called
          with 3 as the argument, and the result is assigned to the 'result'
          variable. When executed, the output will be:</p
        >
        <pre><span>9</span></pre>
      </article>
      <article>
        <h2>04- Keyword Arguments</h2>
        <p
          >In Python, you can pass arguments to a function by either position or
          by using keywords. When you pass arguments by keyword, the order of
          the arguments doesn't matter, as long as you specify the keyword for
          each argument.</p
        >
        <p>Here's an example:</p>
        <pre class="language-python">
<code>def greet(first_name, last_name):
            print(f"Hello, {first_name} {last_name}!")
        # Call the function by position
        greet("John", "Doe")
        
        # Call the function by keyword
        greet(last_name="Doe", first_name="John")</code></pre>

        <p
          >The above code defines a function named 'greet' that takes two
          parameters, 'first_name' and 'last_name'. The first call to the
          function passes the arguments by position, which means that the first
          argument ('John') is assigned to the 'first_name' parameter, and the
          second argument ('Doe') is assigned to the 'last_name' parameter. The
          second call to the function uses keyword arguments, which means that
          the order of the arguments doesn't matter, as long as the keyword is
          specified for each argument.</p
        >
        <p>You can also mix positional and keyword arguments:</p>
        <pre
          class="language-python"
        ><code>def greet(first_name, last_name, city):
            print(f"Hello, {first_name} {last_name} from {city}!")
        # Call the function with positional and keyword arguments
        greet("John", "Doe", city="New York")</code></pre>

        <p
          >The above code defines a function named 'greet' that takes three
          parameters, 'first_name', 'last_name', and 'city'. The function is
          called with two positional arguments ('John' and 'Doe') and one
          keyword argument ('city="New York"').</p
        >
        <p
          >When using keyword arguments, it's important to make sure that the
          keywords match the parameter names in the function definition,
          otherwise you will get a 'TypeError'.</p
        >
      </article>
      <article>
        <h2>05- Default Arguments</h2>
        <p
          >In Python, you can define default values for function arguments. This
          means that if a value is not provided for an argument when the
          function is called, the default value will be used.</p
        >
        <p>Here's an example:</p>
        <pre class="language-python">
<code>def greet(name, greeting="Hello"):
            print(f"{greeting}, {name}!")
        # Call the function with one argument
        greet("John")
        
        # Call the function with two arguments
        greet("Jane", "Hi")</code></pre>

        <p
          >The above code defines a function named 'greet' that takes two
          parameters, 'name' and 'greeting', with a default value of "Hello" for
          the 'greeting' parameter. The first call to the function only passes
          the 'name' parameter, which means that the default value of "Hello" is
          used for the 'greeting' parameter. The second call to the function
          passes both the 'name' and 'greeting' parameters, so the default value
          is overridden.</p
        >
        <p
          >Note that default arguments must be specified after non-default
          arguments in the function definition. For example, this will result in
          a syntax error:</p
        >
        <pre class="language-python">
<code>def greet(greeting="Hello", name):
            print(f"{greeting}, {name}!")</code></pre>
        <p>To avoid this error, you can define the function like this:</p>
        <pre class="language-python">
<code>def greet(name, greeting="Hello"):
            print(f"{greeting}, {name}!")</code></pre>
      </article>
      <article>
        <h2>06- *args</h2>
        <p
          >In Python, you can define a function that takes a variable number of
          arguments by using the '*args' syntax. This allows you to pass any
          number of arguments to the function.</p
        >
        <p>Here's an example:</p>
        <pre class="language-python">
<code>def add_numbers(*numbers):
            total = 0
            for number in numbers:
                total += number
            print(f"The sum of the numbers is {total}.")
        # Call the function with three arguments
        add_numbers(1, 2, 3)
        
        # Call the function with four arguments
        add_numbers(4, 5, 6, 7)</code></pre>

        <p
          >The above code defines a function named 'add_numbers' that takes a
          variable number of arguments using the '*numbers' syntax. The function
          loops through all of the arguments and adds them together to calculate
          the total sum.</p
        >
        <p
          >When calling the function, you can pass any number of arguments by
          separating them with commas. In this example, the function is called
          twice with different numbers of arguments.</p
        >
      </article>
      <article>
        <h2>07- **kwargs</h2>
        <p
          >In Python, you can also define a function that takes a variable
          number of keyword arguments by using the '**kwargs' syntax. This
          allows you to pass any number of keyword arguments to the function.</p
        >
        <p>Here's an example:</p>
        <pre class="language-python">
<code>def print_user_info(**user_info):
            for key, value in user_info.items():
                print(f"{key}: {value}")
        #v Call the function with two keyword arguments
        print_user_info(name="John", age=30)
        
        # Call the function with three keyword arguments
        print_user_info(name="Jane", age=25, city="New York")</code></pre>

        <p
          >The above code defines a function named 'print_user_info' that takes
          a variable number of keyword arguments using the '**user_info' syntax.
          The function loops through all of the keyword arguments and prints out
          their names and values.</p
        >
        <p
          >When calling the function, you can pass any number of keyword
          arguments by specifying their names and values using the 'name=value'
          syntax. In this example, the function is called twice with different
          numbers of keyword arguments.</p
        >
      </article>
      <article>
        <h2>08- Scope</h2>
        <p
          >The scope of a variable in Python is the region of the code where
          that variable can be accessed. There are two main types of scope in
          Python: global scope and local scope.</p
        >
        <p
          >Global scope refers to variables that are defined outside of any
          function. These variables can be accessed from anywhere in the code,
          including inside functions. However, if a function defines a variable
          with the same name as a global variable, the function's local variable
          will take precedence over the global variable within the function's
          scope.</p
        >
        <p
          >Local scope refers to variables that are defined inside of a
          function. These variables can only be accessed within the function's
          scope and are destroyed when the function returns. However, if a
          variable is defined outside of a function and then referenced inside
          the function, Python will assume that the variable is a global
          variable and try to access it from the global scope.</p
        >
        <p>Here's an example:</p>
        <pre class="language-python">
<code>x = 10  # Global variable
        def my_function():
        x = 5 # Local variable
        print(f"x inside function is {x}")
        
        my_function()
        print(f"x outside function is {x}")</code></pre>

        <p
          >In this example, we define a global variable 'x' with a value of 10.
          We then define a function 'my_function' that defines a local variable
          'x' with a value of 5. When we call the function, it prints out the
          value of the local variable 'x' inside the function's scope. When we
          print out the value of 'x' outside of the function's scope, we get the
          value of the global variable 'x'.</p
        >
        <p
          >Note that if we didn't define a local variable 'x' inside the
          function, Python would have assumed that we were referencing the
          global variable 'x' and printed out its value instead.</p
        >
      </article>
      <article>
        <h2>09- Debugging in Visual Studio Code</h2>
        <p
          >Visual Studio Code is a powerful integrated development environment
          (IDE) that comes with built-in debugging tools for Python. These tools
          can help you find and fix errors in your code more quickly and
          easily.</p
        >
        <p
          >To start debugging your Python code in Visual Studio Code, you need
          to:</p
        >
        <ol>
          <li
            >Set a breakpoint in your code by clicking on the left margin of the
            line where you want to stop execution.</li
          >
          <li
            >Start debugging by clicking the "Run" button in the left toolbar or
            by pressing F5 on your keyboard.</li
          >
          <li
            >Once the debugger stops at the breakpoint, you can use the
            debugging toolbar to step through your code, inspect variables, and
            watch expressions.</li
          >
        </ol>
        <p>Here's an example:</p>
        <pre class="language-python">
<code>def calculate_sum(a, b):
            result = a + b
            return result
        x = 5
        y = 10
        
        sum = calculate_sum(x, y)
        
        print(sum)</code></pre>

        <p
          >In this example, we define a function 'calculate_sum' that takes two
          arguments 'a' and 'b' and returns their sum. We then define two
          variables 'x' and 'y' with values of 5 and 10, respectively. We call
          the 'calculate_sum' function with 'x' and 'y' as arguments and assign
          the result to a variable 'sum'. Finally, we print out the value of
          'sum'.</p
        >
        <p
          >To debug this code in Visual Studio Code, we can set a breakpoint on
          the line that calls the 'calculate_sum' function and start debugging.
          Once the debugger stops at the breakpoint, we can use the debugging
          toolbar to step through the code and inspect the values of 'x', 'y',
          'result', and 'sum' at each step.</p
        >
      </article>
      <article>
        <h2>10- Visual Studio Code Coding Tricks</h2>
        <p
          >Visual Studio Code is a highly customizable IDE that offers many
          useful coding tricks and shortcuts to help you write code more
          efficiently. Here are some useful coding tricks in Visual Studio
          Code:</p
        >
        <ol>
          <li
            ><strong>Intellisense:</strong> Visual Studio Code has a powerful
            Intellisense feature that provides suggestions for keywords,
            functions, and variable names as you type. You can use the arrow
            keys or Tab to select the suggestion you want.</li
          >
          <li
            ><strong>Multiple Cursors:</strong> Visual Studio Code allows you to
            create multiple cursors by holding down the Alt key and clicking at
            different locations in your code. This can be useful for editing
            multiple lines at once.</li
          >
          <li
            ><strong>Code Formatting:</strong> Visual Studio Code has built-in
            code formatting features that can help you keep your code clean and
            consistent. You can format your code by pressing Shift+Alt+F.</li
          >
          <li
            ><strong>Code Navigation:</strong> Visual Studio Code has many
            shortcuts for quickly navigating through your code. For example, you
            can jump to a function definition by pressing F12, or you can go
            back to the previous location by pressing Ctrl+-.</li
          >
          <li
            ><strong>Integrated Terminal:</strong> Visual Studio Code has an
            integrated terminal that allows you to run commands and scripts
            directly within the IDE. You can open the terminal by pressing
            Ctrl+Shift+`.</li
          >
          <li
            ><strong>Code Snippets:</strong> Visual Studio Code has built-in
            code snippets that allow you to quickly insert common code patterns.
            You can access these snippets by typing the name of the code snippet
            and then pressing Tab.</li
          >
          <li
            ><strong>Code Folding:</strong> Visual Studio Code allows you to
            fold sections of code to make it easier to read. You can fold a
            section of code by clicking on the small triangle icon next to the
            line number.</li
          >
          <li
            ><strong>Git Integration:</strong> Visual Studio Code has built-in
            Git integration that allows you to manage your code repositories
            directly within the IDE. You can access Git commands by clicking on
            the Git icon in the left toolbar.</li
          >
        </ol>
        <p
          >These are just a few of the many coding tricks and shortcuts
          available in Visual Studio Code. By taking advantage of these
          features, you can write code more efficiently and effectively.</p
        >
      </article>
      <h2 class="a-main-topic">05 Data Structures</h2>

      <article>
        <h2>01- Lists</h2>
        <p
          >Lists are one of the most commonly used data structures in Python.
          They are ordered, mutable, and can hold any type of object. Lists are
          defined using square brackets and can contain any number of objects
          separated by commas. Here is an example of how to create and
          manipulate a list:</p
        >
        <pre class="language-python">
<code># Creating a list
my_list = [1, 2, 3, 'apple', 'banana']
# Accessing elements of a list
print(my_list[0]) # Output: 1
print(my_list[-1]) # Output: 'banana'

# Slicing a list
print(my_list[1:3]) # Output: [2, 3]

#v Modifying elements of a list
my_list[3] = 'orange'
print(my_list) # Output: [1, 2, 3, 'orange', 'banana']

# Adding elements to a list
my_list.append('grape')
print(my_list) # Output: [1, 2, 3, 'orange', 'banana', 'grape']</code></pre>

        <p
          >Lists also support a wide range of built-in methods, such as
          <span>sort()</span>, <span>reverse()</span>, and <span>pop()</span>.
          You can also use the <span>len()</span> function to get the length of
          a list and the <span>in</span> keyword to check if an element is in a
          list.</p
        >
      </article>
      <article>
        <h2>02- Accessing Items</h2>
        <p
          >In Python, you can access individual items in a list using indexing.
          Indexing starts at 0 for the first item and continues to N-1 for the
          last item, where N is the length of the list. Negative indexing can
          also be used to access items from the end of the list, with -1
          representing the last item.</p
        >
        <p>Here is an example of accessing items in a list:</p>
        <pre
          class="language-python"
        ><code>my_list = ['apple', 'banana', 'orange', 'grape']
      print(my_list[0])  # Output: 'apple'
      print(my_list[2])  # Output: 'orange'
      print(my_list[-1])  # Output: 'grape'</code></pre>
        <p>You can also use slicing to access a range of items in a list:</p>
        <pre
          class="language-python"
        ><code>my_list = ['apple', 'banana', 'orange', 'grape']
      print(my_list[1:3])  # Output: ['banana', 'orange']
      print(my_list[:2])  # Output: ['apple', 'banana']
      print(my_list[2:])  # Output: ['orange', 'grape']</code></pre>
        <p
          >Note that slicing returns a new list, not a view on the original
          list. So modifying the sliced list will not affect the original
          list.</p
        >
      </article>
      <article>
        <h2>03- List Unpacking</h2>
        <p
          >List unpacking is a useful feature in Python that allows you to
          assign multiple variables from a list in one line of code. This can be
          especially helpful when working with functions that return multiple
          values in a list.</p
        >
        <p>Here is an example of list unpacking:</p>
        <pre
          class="language-python"
        ><code>my_list = ['apple', 'banana', 'orange']
      a, b, c = my_list
      print(a)  # Output: 'apple'
      print(b)  # Output: 'banana'
      print(c)  # Output: 'orange'</code></pre>
        <p
          >In this example, the variables <span>a</span>, <span>b</span>, and
          <span>c</span> are assigned the values from the list
          <span>my_list</span> in order. If the number of variables on the left
          side of the assignment operator does not match the length of the list,
          a <span>ValueError</span> will be raised.</p
        >
        <p
          >You can also use list unpacking with the asterisk (*) operator to
          capture all remaining values in a list:</p
        >
        <pre
          class="language-python"
        ><code>my_list = ['apple', 'banana', 'orange', 'grape']
      a, b, *c = my_list
      print(a)  # Output: 'apple'
      print(b)  # Output: 'banana'
      print(c)  # Output: ['orange', 'grape']</code></pre>
        <p
          >In this example, the variables <span>a</span> and <span>b</span> are
          assigned the first two values from the list, while <span>c</span> is
          assigned a list containing the remaining values.</p
        >
      </article>
      <article>
        <h2>04- Looping over Lists</h2>
        <p
          >Looping over a list is a common task in Python. There are several
          ways to loop over a list, including using a <span>for</span> loop and
          the <span>enumerate()</span> function.</p
        >
        <p
          >Here is an example of using a <span>for</span> loop to iterate over a
          list:</p
        >
        <pre
          class="language-python"
        ><code>my_list = ['apple', 'banana', 'orange']
      for fruit in my_list:
          print(fruit)</code></pre>
        <p>This code will output:</p>
        <pre>
apple
      banana
      orange</pre
        >
        <p
          >You can also use the <span>enumerate()</span> function to loop over a
          list and access the index of each item:</p
        >
        <pre
          class="language-python"
        ><code>my_list = ['apple', 'banana', 'orange']
      for i, fruit in enumerate(my_list):
          print(i, fruit)</code></pre>
        <p>This code will output:</p>
        <pre>
0 apple
      1 banana
      2 orange</pre
        >
        <p
          >Finally, you can also loop over a list in reverse order by using the
          <span>reversed()</span> function:</p
        >
        <pre
          class="language-python"
        ><code>my_list = ['apple', 'banana', 'orange']
      for fruit in reversed(my_list):
          print(fruit)</code></pre>
        <p>This code will output:</p>
        <pre>
orange
      banana
      apple</pre
        >
      </article>
      <article>
        <h2>05- Adding or Removing Items</h2>
        <p
          >Lists are mutable in Python, which means you can add or remove items
          from a list after it has been created. There are several methods you
          can use to modify a list, including <span>append()</span>,
          <span>extend()</span>, <span>insert()</span>, <span>remove()</span>,
          and <span>pop()</span>.</p
        >
        <h3>Adding Items</h3>
        <p
          >The <span>append()</span> method adds an item to the end of a
          list:</p
        >
        <pre
          class="language-python"
        ><code>fruits = ['apple', 'banana', 'orange']
      fruits.append('grape')
      print(fruits)  # Output: ['apple', 'banana', 'orange', 'grape']</code></pre>
        <p
          >The <span>extend()</span> method adds multiple items to the end of a
          list:</p
        >
        <pre
          class="language-python"
        ><code>fruits = ['apple', 'banana', 'orange']
      more_fruits = ['grape', 'pear']
      fruits.extend(more_fruits)
      print(fruits)  # Output: ['apple', 'banana', 'orange', 'grape', 'pear']</code></pre>
        <p
          >The <span>insert()</span> method adds an item at a specified index in
          a list:</p
        >
        <pre
          class="language-python"
        ><code>fruits = ['apple', 'banana', 'orange']
      fruits.insert(1, 'grape')
      print(fruits)  # Output: ['apple', 'grape', 'banana', 'orange']</code></pre>
        <h3>Removing Items</h3>
        <p
          >The <span>remove()</span> method removes the first occurrence of an
          item from a list:</p
        >
        <pre
          class="language-python"
        ><code>fruits = ['apple', 'banana', 'orange', 'banana']
      fruits.remove('banana')
      print(fruits)  # Output: ['apple', 'orange', 'banana']</code></pre>
        <p
          >The <span>pop()</span> method removes and returns an item at a
          specified index in a list:</p
        >
        <pre
          class="language-python"
        ><code>fruits = ['apple', 'banana', 'orange']
      popped_fruit = fruits.pop(1)
      print(popped_fruit)  # Output: 'banana'
      print(fruits)  # Output: ['apple', 'orange']</code></pre>
      </article>
      <article>
        <h2>06- Finding Items</h2>
        <p
          >Python provides several ways to find items in a list, including using
          the <span>in</span> operator, the <span>index()</span> method, and the
          <span>count()</span> method.</p
        >
        <h3>Using the <span>in</span> Operator</h3>
        <p
          >You can use the <span>in</span> operator to check if an item is in a
          list:</p
        >
        <pre
          class="language-python"
        ><code>fruits = ['apple', 'banana', 'orange']
      if 'banana' in fruits:
          print('Found banana!')</code></pre>
        <p>This code will output:</p>
        <pre>Found banana!</pre>
        <h3>Using the <span>index()</span> Method</h3>
        <p
          >The <span>index()</span> method returns the index of the first
          occurrence of an item in a list:</p
        >
        <pre
          class="language-python"
        ><code>fruits = ['apple', 'banana', 'orange']
      banana_index = fruits.index('banana')
      print(banana_index)  # Output: 1</code></pre>
        <p>If the item is not found, a <span>ValueError</span> is raised:</p>
        <pre
          class="language-python"
        ><code>fruits = ['apple', 'banana', 'orange']
      try:
          grape_index = fruits.index('grape')
      except ValueError:
          print('Grape not found.')</code></pre>
        <p>This code will output:</p>
        <pre>Grape not found.</pre>
        <h3>Using the <span>count()</span> Method</h3>
        <p
          >The <span>count()</span> method returns the number of times an item
          appears in a list:</p
        >
        <pre
          class="language-python"
        ><code>fruits = ['apple', 'banana', 'orange', 'banana']
      banana_count = fruits.count('banana')
      print(banana_count)  # Output: 2</code></pre>
      </article>

      <article>
        <h2>07- Sorting Lists</h2>
        <p
          >Python provides several ways to sort a list, including the
          <span>sort()</span> method and the <span>sorted()</span> function.</p
        >
        <h3>The <span>sort()</span> Method</h3>
        <p>The <span>sort()</span> method sorts a list in place:</p>
        <pre
          class="language-python"
        ><code>fruits = ['banana', 'orange', 'apple']
fruits.sort()
print(fruits)  # Output: ['apple', 'banana', 'orange']</code></pre>
        <p>The <span>sort()</span> method can take two optional arguments:</p>
        <ul>
          <li
            ><code>reverse</code>: If set to <code>True</code>, the list will be
            sorted in descending order. The default value is
            <code>False</code>.</li
          >
          <li
            ><code>key</code>: A function that takes an item and returns a value
            that will be used as the sort key. The default value is
            <code>None</code>.</li
          >
        </ul>
        <pre
          class="language-python"
        ><code>fruits = ['banana', 'orange', 'apple']
fruits.sort(reverse=True)
print(fruits)  # Output: ['orange', 'banana', 'apple']
fruits = [('banana', 2), ('orange', 1), ('apple', 3)]
fruits.sort(key=lambda x: x[1])
print(fruits) # Output: [('orange', 1), ('banana', 2), ('apple', 3)]</code></pre>

        <h3>The <span>sorted()</span> Function</h3>
        <p>The <span>sorted()</span> function returns a new sorted list:</p>
        <pre
          class="language-python"
        ><code>fruits = ['banana', 'orange', 'apple']
sorted_fruits = sorted(fruits)
print(sorted_fruits)  # Output: ['apple', 'banana', 'orange']</code></pre>
        <p
          >The <span>sorted()</span> function can take the same optional
          arguments as the <span>sort()</span> method:</p
        >
        <pre
          class="language-python"
        ><code>fruits = ['banana', 'orange', 'apple']
sorted_fruits = sorted(fruits, reverse=True)
print(sorted_fruits)  # Output: ['orange', 'banana', 'apple']
fruits = [('banana', 2), ('orange', 1), ('apple', 3)]
sorted_fruits = sorted(fruits, key=lambda x: x[1])
print(sorted_fruits) # Output: [('orange', 1), ('banana', 2), ('apple', 3)]</code></pre>
      </article>
      <article>
        <h2>09- Map Function</h2>
        <p
          >The <span>map()</span> function applies a given function to each item
          of an iterable (e.g., a list) and returns a new iterable with the
          results:</p
        >
        <pre class="language-python">
<code>def square(x):
          return x ** 2
      numbers = [1, 2, 3, 4, 5]
      squares = map(square, numbers)
      print(list(squares)) # Output: [1, 4, 9, 16, 25]</code></pre>

        <p
          >The <span>map()</span> function can also take multiple iterables as
          arguments, in which case the given function must take as many
          arguments as there are iterables:</p
        >
        <pre class="language-python">
<code>def add(x, y):
          return x + y
      numbers1 = [1, 2, 3]
      numbers2 = [4, 5, 6]
      sums = map(add, numbers1, numbers2)
      print(list(sums)) # Output: [5, 7, 9]</code></pre>

        <p
          >Instead of defining a separate function for the given operation, you
          can use a lambda function:</p
        >
        <pre class="language-python">
<code>numbers = [1, 2, 3, 4, 5]
      squares = map(lambda x: x ** 2, numbers)
      print(list(squares))  # Output: [1, 4, 9, 16, 25]</code></pre>
        <p
          >The <span>map()</span> function returns a map object, which is an
          iterator, so you can use a loop to iterate over the results:</p
        >
        <pre class="language-python">
<code>numbers = [1, 2, 3, 4, 5]
      squares = map(lambda x: x ** 2, numbers)
      for square in squares:
          print(square)  # Output: 1 4 9 16 25</code></pre>
      </article>
      <article>
        <h2>10- Filter Function</h2>
        <p
          >The <span>filter()</span> function creates a new iterable by
          filtering out items from an existing iterable that don't meet a
          certain condition:</p
        >
        <pre class="language-python">
<code>def is_even(x):
          return x % 2 == 0
      numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      evens = filter(is_even, numbers)
      print(list(evens)) # Output: [2, 4, 6, 8, 10]</code></pre>

        <p
          >You can also use a lambda function instead of defining a separate
          function:</p
        >
        <pre
          class="language-python"
        ><code>numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      evens = filter(lambda x: x % 2 == 0, numbers)
      print(list(evens))  # Output: [2, 4, 6, 8, 10]</code></pre>
        <p
          >The <span>filter()</span> function returns a filter object, which is
          an iterator, so you can use a loop to iterate over the results:</p
        >
        <pre
          class="language-python"
        ><code>numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      evens = filter(lambda x: x % 2 == 0, numbers)
      for even in evens:
          print(even)  # Output: 2 4 6 8 10</code></pre>
      </article>

      <article>
        <h2>11- List Comprehensions</h2>
        <p
          >List comprehensions provide a concise way to create lists based on
          existing lists or other iterables:</p
        >
        <pre class="language-python">
<code>numbers = [1, 2, 3, 4, 5]
squares = [x ** 2 for x in numbers]
print(squares)  # Output: [1, 4, 9, 16, 25]</code></pre>
        <p>The basic syntax for a list comprehension is:</p>
        <pre>[expression for item in iterable]</pre>
        <p
          >You can also add a condition to the comprehension to filter the
          results:</p
        >
        <pre class="language-python">
<code>numbers = [1, 2, 3, 4, 5]
evens = [x for x in numbers if x % 2 == 0]
print(evens)  # Output: [2, 4]</code></pre>
        <p
          >You can even use multiple for loops and conditions in a single
          comprehension:</p
        >
        <pre class="language-python">
<code>numbers1 = [1, 2, 3]
numbers2 = [4, 5, 6]
products = [x * y for x in numbers1 for y in numbers2 if x + y > 5]
print(products)  # Output: [8, 10, 12, 15, 18]</code></pre>
      </article>
      <article>
        <h2>12- Zip Function</h2>
        <p
          >The <span>zip()</span> function takes multiple iterables and returns
          an iterator of tuples that contain the corresponding elements from
          each iterable:</p
        >
        <pre class="language-python">
<code>numbers = [1, 2, 3]
      letters = ['a', 'b', 'c']
      zipped = zip(numbers, letters)
      print(list(zipped))  # Output: [(1, 'a'), (2, 'b'), (3, 'c')]</code></pre>
        <p
          >If the iterables are of different lengths, the iterator stops when
          the shortest iterable is exhausted:</p
        >
        <pre class="language-python">
<code>numbers = [1, 2, 3]
      letters = ['a', 'b', 'c', 'd']
      zipped = zip(numbers, letters)
      print(list(zipped))  # Output: [(1, 'a'), (2, 'b'), (3, 'c')]</code></pre>
        <p
          >You can also use the <span>zip()</span> function to unzip a list of
          tuples:</p
        >
        <pre
          class="language-python"
        ><code>pairs = [(1, 'a'), (2, 'b'), (3, 'c')]
      numbers, letters = zip(*pairs)
      print(numbers)  # Output: (1, 2, 3)
      print(letters)  # Output: ('a', 'b', 'c')</code></pre>
      </article>
      <article>
        <h2>13- Stacks</h2>
        <p
          >A stack is a collection of elements that supports two main
          operations:</p
        >
        <ul>
          <li><b>Push:</b> adds an element to the top of the stack.</li>
          <li
            ><b>Pop:</b> removes and returns the element at the top of the
            stack.</li
          >
        </ul>
        <p
          >Stacks follow the <b>Last In First Out (LIFO)</b> principle, which
          means that the last element added to the stack will be the first
          element to be removed.</p
        >
        <p
          >In Python, you can implement a stack using a list. Here's an
          example:</p
        >
        <pre class="language-python">
<code>stack = []
      stack.append(1)  # Push
      stack.append(2)  # Push
      stack.append(3)  # Push
      print(stack)  # Output: [1, 2, 3]
      top = stack.pop() # Pop
      print(top) # Output: 3
      print(stack) # Output: [1, 2]</code></pre>

        <p
          >The <span>append()</span> method is used to push an element onto the
          stack, and the <span>pop()</span> method is used to pop the top
          element from the stack.</p
        >
      </article>
      <article>
        <h2>14- Queues</h2>
        <p
          >A queue is a collection of elements that supports two main
          operations:</p
        >
        <ul>
          <li><b>Enqueue:</b> adds an element to the back of the queue.</li>
          <li
            ><b>Dequeue:</b> removes and returns the element at the front of the
            queue.</li
          >
        </ul>
        <p
          >Queues follow the <b>First In First Out (FIFO)</b> principle, which
          means that the first element added to the queue will be the first
          element to be removed.</p
        >
        <p
          >In Python, you can implement a queue using a list. Here's an
          example:</p
        >
        <pre class="language-python">
<code>queue = []
      queue.append(1)  # Enqueue
      queue.append(2)  # Enqueue
      queue.append(3)  # Enqueue
      print(queue)  # Output: [1, 2, 3]
      front = queue.pop(0) # Dequeue
      print(front) # Output: 1
      print(queue) # Output: [2, 3]</code></pre>

        <p
          >The <span>append()</span> method is used to enqueue an element to the
          back of the queue, and the <span>pop(0)</span> method is used to
          dequeue the element at the front of the queue.</p
        >
      </article>
      <article>
        <h2>15- Tuples</h2>
        <p
          >A tuple is an ordered, immutable collection of elements. This means
          that once a tuple is created, its contents cannot be changed.</p
        >
        <p
          >In Python, tuples are represented using parentheses and commas.
          Here's an example:</p
        >
        <pre class="language-python">
<code>tuple1 = (1, 2, 3)
      tuple2 = ('apple', 'banana', 'cherry')
      tuple3 = (True, False)
      print(tuple1) # Output: (1, 2, 3)
      print(tuple2) # Output: ('apple', 'banana', 'cherry')
      print(tuple3) # Output: (True, False)</code></pre>

        <p
          >You can access elements of a tuple using indexing, just like with
          lists:</p
        >
        <pre class="language-python">
<code>tuple1 = (1, 2, 3)
      print(tuple1[0])  # Output: 1
      print(tuple1[1])  # Output: 2
      print(tuple1[2])  # Output: 3</code></pre>
        <p
          >Tuples can be useful when you want to store a collection of values
          that should not be changed. For example, you might use a tuple to
          represent a point in two-dimensional space:</p
        >
        <pre class="language-python">
<code>point = (3, 4)
      print(point[0])  # Output: 3
      print(point[1])  # Output: 4</code></pre>
      </article>
      <article>
        <h2>16- Swapping Variables</h2>
        <p
          >In Python, you can swap the values of two variables without using a
          temporary variable by using a tuple:</p
        >
        <pre class="language-python">
<code>x = 10
      y = 5
      x, y = y, x
      print(x)  # Output: 5
      print(y)  # Output: 10</code></pre>
        <p
          >This code first creates a tuple containing the values of
          <span>x</span> and <span>y</span>, then assigns the values in reverse
          order back to the variables <span>x</span> and <span>y</span>,
          effectively swapping their values.</p
        >
      </article>
      <article>
        <h2>17- Arrays</h2>
        <p
          >An array is a data structure that stores a collection of elements,
          typically of the same type. In Python, arrays can be created using the
          <code>array</code> module.</p
        >
        <p>Here's an example:</p>
        <pre class="language-python">
<code>import array
      # Create an array of integers
      arr1 = array.array('i', [1, 2, 3, 4, 5])
      
      # Create an array of floating-point numbers
      arr2 = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])
      
      print(arr1) # Output: array('i', [1, 2, 3, 4, 5])
      print(arr2) # Output: array('d', [1.0, 2.0, 3.0, 4.0, 5.0])</code></pre>

        <p
          >The first argument to the <code>array</code> constructor specifies
          the type of the elements in the array. The 'i' type code represents
          integers, and the 'd' type code represents floating-point numbers.</p
        >
        <p
          >You can access elements of an array using indexing, just like with
          lists and tuples:</p
        >
        <pre
          class="language-python"
        ><code>arr = array.array('i', [1, 2, 3, 4, 5])
      print(arr[0])  # Output: 1
      print(arr[1])  # Output: 2
      print(arr[2])  # Output: 3</code></pre>
        <p
          >Arrays can be useful when you need to store a large number of
          elements of the same type in a more memory-efficient way than a
          list.</p
        >
      </article>
      <article>
        <h2>18- Sets</h2>
        <p
          >A set is an unordered collection of unique elements. In Python, sets
          can be created using the <code>set</code> function or by enclosing a
          list of elements in curly braces:</p
        >
        <pre class="language-python">
<code>set1 = set([1, 2, 3, 4, 5])
      set2 = {4, 5, 6, 7, 8}</code></pre>
        <p
          >Since sets contain only unique elements, adding an element that
          already exists in the set will have no effect:</p
        >
        <pre class="language-python">
<code>set1 = {1, 2, 3}
      set1.add(3)
      print(set1)  # Output: {1, 2, 3}</code></pre>
        <p
          >You can perform set operations such as union, intersection, and
          difference using the corresponding methods or operators:</p
        >
        <pre class="language-python">
<code>set1 = {1, 2, 3}
      set2 = {2, 3, 4}
      # Union
      print(set1.union(set2)) # Output: {1, 2, 3, 4}
      
      # Intersection
      print(set1.intersection(set2)) # Output: {2, 3}
      
      # Difference
      print(set1.difference(set2)) # Output: {1}</code></pre>

        <p
          >Sets can be useful when you need to check for duplicates or perform
          set operations on collections of elements.</p
        >
      </article>

      <article>
        <h2>19- Dictionaries</h2>
        <p
          >A dictionary is an unordered collection of key-value pairs. In
          Python, dictionaries are defined using curly braces {} with key-value
          pairs separated by colons:</p
        >
        <pre
          class="language-python"
        ><code>my_dict = {'name': 'John', 'age': 30, 'city': 'New York'}</code></pre>
        <p>You can access the values in a dictionary using the keys:</p>
        <pre class="language-python">
<code>name = my_dict['name']
age = my_dict['age']
print(name, age)  # Output: John 30</code></pre>
        <p>You can also add, modify, and delete key-value pairs:</p>
        <pre class="language-python">
<code># Add a new key-value pair
my_dict['occupation'] = 'Programmer'
# Modify an existing value
my_dict['age'] = 31

# Delete a key-value pair
del my_dict['city']</code></pre>

        <p
          >You can iterate over the keys, values, or items (key-value pairs) in
          a dictionary using the corresponding methods:</p
        >
        <pre class="language-python">
<code># Iterate over keys
for key in my_dict.keys():
    print(key)
# Iterate over values
for value in my_dict.values():
print(value)

# Iterate over items
for key, value in my_dict.items():
print(key, value)</code></pre>

        <p
          >Dictionaries are commonly used for storing and retrieving data in a
          structured format.</p
        >
      </article>
      <article>
        <h2>20- Dictionary Comprehensions</h2>
        <p
          >Like list comprehensions, dictionary comprehensions are a concise way
          of creating dictionaries in Python. They follow a similar syntax to
          list comprehensions, but with key-value pairs separated by a colon:</p
        >
        <pre
          class="language-python"
        ><code>my_dict = {key: value for key, value in iterable}</code></pre>
        <p
          >Here's an example of creating a dictionary using a dictionary
          comprehension:</p
        >
        <pre
          class="language-python"
        ><code>squares = {num: num*num for num in range(1, 6)}
      print(squares)  # Output: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}</code></pre>
        <p
          >You can also add conditions to dictionary comprehensions using if
          statements:</p
        >
        <pre
          class="language-python"
        ><code>odd_squares = {num: num*num for num in range(1, 6) if num % 2 == 1}
      print(odd_squares)  # Output: {1: 1, 3: 9, 5: 25}</code></pre>
        <p
          >Dictionary comprehensions can be a powerful tool for creating
          dictionaries in a concise and readable way.</p
        >
      </article>
      <article>
        <h2>21- Generator Expressions</h2>
        <p
          >Generator expressions are a way to create generators in a concise and
          memory-efficient way. They follow a similar syntax to list
          comprehensions, but with parentheses instead of square brackets:</p
        >
        <pre
          class="language-python"
        ><code>my_gen = (expression for item in iterable)</code></pre>
        <p
          >Here's an example of creating a generator expression that generates
          the squares of the first five numbers:</p
        >
        <pre
          class="language-python"
        ><code>squares = (num*num for num in range(1, 6))
      print(squares)  # Output: &lt;generator object &lt;genexpr&gt; at 0x7f43b8e98580&gt;</code></pre>
        <p
          >The resulting object is a generator object, which can be used to
          generate the values on the fly:</p
        >
        <pre
          class="language-python"
        ><code>squares = (num*num for num in range(1, 6))
      for square in squares:
          print(square)  # Output: 1 4 9 16 25</code></pre>
        <p
          >Generator expressions can be a powerful tool for generating large
          sequences of values without having to store them all in memory at
          once.</p
        >
      </article>

      <article>
        <h2>22- Unpacking Operator</h2>
        <p
          >The unpacking operator, denoted by the asterisk (<code>*</code>)
          symbol, is a powerful feature in Python that allows you to unpack
          elements from an iterable into separate variables or arguments.</p
        >
        <p>Here's an example of unpacking a list into separate variables:</p>
        <pre class="language-python">
<code>my_list = [1, 2, 3]
a, b, c = my_list
print(a, b, c)  # Output: 1 2 3</code></pre>
        <p
          >You can also use the unpacking operator to combine two or more lists
          into a single list:</p
        >
        <pre class="language-python">
<code>list1 = [1, 2, 3]
list2 = [4, 5, 6]
combined_list = [*list1, *list2]
print(combined_list)  # Output: [1, 2, 3, 4, 5, 6]</code></pre>
        <p
          >The unpacking operator can also be used with dictionaries to unpack
          key-value pairs:</p
        >
        <pre class="language-python">
<code>my_dict = {'a': 1, 'b': 2, 'c': 3}
for key, value in my_dict.items():
    print(key, value)  # Output: a 1, b 2, c 3
keys = [*my_dict]
values = [*my_dict.values()]
print(keys)  # Output: ['a', 'b', 'c']
print(values)  # Output: [1, 2, 3]</code></pre>
        <p
          >The unpacking operator is a powerful tool for working with iterables
          in Python, and can simplify your code and make it more readable.</p
        >
      </article>
      <h2 class="a-main-topic">06 Exceptions</h2>
      <article>
        <h2>01- Exceptions (Introduction)</h2>
        <p
          >Exceptions are events that occur during the execution of a program
          that disrupt the normal flow of instructions. They are errors that
          happen when something goes wrong in the program and Python cannot cope
          with it.
        </p>
        <p
          >Python provides a way to handle exceptions so that we can gracefully
          recover from errors. We use a try-except block to handle exceptions.
          The try block contains the code that might raise an exception, and the
          except block contains the code that will handle the exception if it is
          raised.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>
    try:
        a = 10 / 0
    except ZeroDivisionError:
        print("Oops! Division by zero error occurred.")
        </code></pre>
        <p
          >In this example, we are trying to divide 10 by 0 which is not
          allowed. This will raise a ZeroDivisionError. We catch this exception
          using the except block and print a message to the user.
        </p>
        <p
          >There are many built-in exceptions in Python, such as ValueError,
          TypeError, NameError, etc. We can also create our own custom
          exceptions by creating a new class that inherits from the Exception
          class.</p
        >
      </article>
      <article>
        <h2>02- Handling Exceptions</h2>
        <p
          >As we learned in the previous note, when an exception is raised, it
          is caught by the except block. However, we can also specify which type
          of exception we want to catch. This allows us to have different
          exception handling code for different types of exceptions.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>
    try:
        a = int(input("Enter a number: "))
        b = int(input("Enter another number: "))
        result = a / b
    except ZeroDivisionError:
        print("Oops! Division by zero error occurred.")
    except ValueError:
        print("Oops! Invalid input.")
    else:
        print("The result is:", result)
        </code></pre>
        <p
          >In this example, we are asking the user to enter two numbers. We then
          try to divide the first number by the second number. If the user
          enters 0 as the second number, a ZeroDivisionError will be raised. If
          the user enters a non-numeric value, a ValueError will be raised. We
          catch these exceptions using separate except blocks. If no exceptions
          are raised, the else block is executed.</p
        >
        <p
          >We can also use a finally block to ensure that some code is always
          executed, regardless of whether an exception was raised or not. For
          example:</p
        >
        <pre class="language-python">
<code>
    try:
        f = open("myfile.txt")
        # some code to read the file
    finally:
        f.close()
        </code></pre>
        <p
          >In this example, we are opening a file and doing some operations on
          it. The finally block ensures that the file is always closed, even if
          an exception was raised while reading the file.</p
        >
      </article>
      <article>
        <h2>03- Handling Different Exceptions</h2>
        <p
          >Sometimes we may want to handle different types of exceptions in the
          same except block. We can do this by specifying the exceptions as a
          tuple.
        </p>
        <p>Here is an example:</p>
        <pre class="language-python">
<code>
    try:
        x = int(input("Enter a number: "))
        y = int(input("Enter another number: "))
        result = x / y
    except (ZeroDivisionError, ValueError, TypeError) as e:
        print("Oops! An exception occurred:", e)
    else:
        print("The result is:", result)
        </code></pre>
        <p
          >In this example, we are trying to divide two numbers entered by the
          user. If the user enters 0 as the second number, a ZeroDivisionError
          will be raised. If the user enters a non-numeric value, a ValueError
          will be raised. If the user enters a value that cannot be converted to
          an integer, a TypeError will be raised. We catch these exceptions
          using a tuple in the except block and print an error message. If no
          exceptions are raised, the else block is executed.</p
        >
        <p
          >We can also use the raise statement to raise our own exceptions. For
          example:</p
        >
        <pre class="language-python">
<code>
    x = -1
    if x < 0:
        raise ValueError("Oops! Negative numbers are not allowed.")
        </code></pre>
        <p
          >In this example, we are checking if the value of x is negative. If it
          is, we raise a ValueError with a custom error message.</p
        >
      </article>
      <article>
        <h2>04- Cleaning Up</h2>
        <p
          >When working with external resources such as files or network
          connections, it is important to clean up properly after we are done
          using them. We can use the try-finally block to ensure that some code
          is always executed, even if an exception was raised.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>
    f = None
    try:
        f = open("myfile.txt")
        # some code to read the file
    finally:
        if f:
            f.close()
        </code></pre>
        <p
          >In this example, we are opening a file and doing some operations on
          it. The finally block ensures that the file is always closed, even if
          an exception was raised while reading the file. We check if the file
          object is not None before calling the close() method to avoid raising
          an AttributeError if the file object was not created successfully.</p
        >
        <p
          >Python also provides the with statement, which automatically takes
          care of closing the file for us, even if an exception was raised.</p
        >
        <pre class="language-python">
<code>
    with open("myfile.txt") as f:
        # some code to read the file
        </code></pre>
        <p
          >In this example, we are opening a file using the with statement. The
          file will be automatically closed when we exit the with block,
          regardless of whether an exception was raised or not.</p
        >
      </article>
      <article>
        <h2>05- The With Statement</h2>
        <p
          >The with statement is used to wrap the execution of a block of code
          with methods defined by a context manager. A context manager is an
          object that defines the methods __enter__() and __exit__() which are
          called at the beginning and end of the block of code, respectively.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>
    class MyContext:
        def __enter__(self):
            print("Entering context")
            return self
        def __exit__(self, exc_type, exc_value, traceback):
            print("Exiting context")
            with MyContext() as context:
              print("Inside context")
</code></pre>
        <p
          >In this example, we define a class called MyContext which defines the
          methods enter() and exit(). The enter() method is called when the with
          statement is executed and returns an object that will be used as the
          context manager. The exit() method is called when the block of code is
          exited, whether normally or due to an exception.</p
        >
        <p
          >When the with statement is executed, the enter() method is called and
          its return value is assigned to the variable context. The code inside
          the with block is then executed, and when it is finished, the exit()
          method is called.</p
        >
        <p
          >The with statement is commonly used to manage resources such as
          files, sockets, and database connections.</p
        >
      </article>
      <article>
        <h2>06- Raising Exceptions</h2>
        <p
          >In addition to handling exceptions raised by Python or by third-party
          libraries, we can also raise our own exceptions to indicate that
          something went wrong in our own code.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>
    def divide(x, y):
        if y == 0:
            raise ZeroDivisionError("division by zero")
        return x / y
    try:
    result = divide(10, 0)
    except ZeroDivisionError as e:
    print(e)
    </code></pre>
        <p
          >In this example, we define a function called divide() which takes two
          arguments and raises a ZeroDivisionError if the second argument is 0.
          We then call this function inside a try-except block and catch the
          exception raised by the function using the ZeroDivisionError class.</p
        >
        <p
          >We can also define our own exception classes by creating a new class
          that inherits from the built-in Exception class or one of its
          subclasses.</p
        >
        <pre class="language-python">
<code>
    class MyException(Exception):
    pass
    
    raise MyException("something went wrong")
    </code></pre>
        <p
          >In this example, we define a new exception class called MyException
          by inheriting from the built-in Exception class. We then raise an
          instance of this class with a custom error message.</p
        >
      </article>
      <article>
        <h2>07- Cost of Raising Exceptions</h2>
        <p
          >While exceptions are a powerful tool for error handling, they do come
          with some performance overhead. Raising an exception requires creating
          a new exception object and unwinding the call stack to find an
          exception handler.</p
        >
        <p
          >For this reason, it is generally recommended to use exceptions
          sparingly and only for exceptional situations. In cases where
          performance is critical, it may be better to use error codes or other
          mechanisms for handling errors.</p
        >
        <p
          >However, it is important to balance performance concerns with the
          readability and maintainability of the code. In many cases, using
          exceptions can make the code easier to understand and maintain, even
          if it comes at a small performance cost.</p
        >
      </article>

      <h2 class="a-main-topic">07 Classes</h2>
      <article>
        <h2>01- Classes (introduction)</h2>
        <p
          >Python is an object-oriented programming language. That means it can
          be used to create objects that have properties and methods. A class is
          like a blueprint for creating objects. In Python, you define a class
          using the <code>class</code> keyword followed by the name of the
          class.</p
        >
        <pre class="language-python">
<code>class MyClass:
          pass</code></pre>
        <p
          >In the above code, we have created a class named
          <code>MyClass</code>. The <code>pass</code> keyword is used when you
          want to create an empty block of code. It is often used as a
          placeholder when writing code that you plan to fill in later.</p
        >
        <p
          >Once you have defined a class, you can create an instance of that
          class. An instance is a specific object created from a particular
          class. You create an instance of a class by calling the class name as
          if it were a function.</p
        >
        <pre class="language-python">
<code>my_object = MyClass()</code></pre>
        <p
          >In the above code, we have created an instance of the
          <code>MyClass</code> class and assigned it to the variable
          <code>my_object</code>.</p
        >
        <p
          >Classes can also have attributes and methods. Attributes are like
          variables that belong to the class, while methods are like functions
          that belong to the class. You can access attributes and methods using
          the dot notation.</p
        >
        <pre class="language-python">
<code>class MyClass:
          my_attribute = "Hello, World!"
      
          def my_method(self):
              print("Hello, World!")
      
      my_object = MyClass()
      print(my_object.my_attribute)
      my_object.my_method()</code></pre>
        <p
          >In the above code, we have added an attribute named
          <code>my_attribute</code> and a method named <code>my_method</code> to
          the <code>MyClass</code> class. We then created an instance of the
          class and used the dot notation to access the attribute and call the
          method.</p
        >
        <p
          >This is just a basic introduction to classes in Python. In later
          topics, we will cover more advanced topics such as inheritance and
          polymorphism.</p
        >
      </article>
      <article>
        <h2>02- Creating Classes</h2>
        <p
          >In Python, a class is like a blueprint for creating objects. You
          define a class using the <code>class</code> keyword followed by the
          name of the class. The body of the class contains attributes and
          methods, which define the properties and behavior of the objects
          created from the class.</p
        >
        <p
          >Let's create a class named <code>Person</code> that has two
          attributes, <code>name</code> and <code>age</code>, and a method
          called <code>greet</code> that prints a greeting message.</p
        >
        <pre class="language-python">
<code>class Person:
          def __init__(self, name, age):
              self.name = name
              self.age = age
      
          def greet(self):
              print(f"Hello, my name is {self.name} and I am {self.age} years old.")</code></pre>
        <p
          >In the above code, we defined a class named <code>Person</code> with
          two attributes, <code>name</code> and <code>age</code>, and a method
          called <code>greet</code>. The <code>__init__</code> method is a
          special method that gets called when an object of the class is
          created. It initializes the attributes of the object.</p
        >
        <p
          >To create an instance of the <code>Person</code> class, we call the
          class like a function and pass in the required arguments:</p
        >
        <pre class="language-python">
<code>p = Person("John", 30)</code></pre>
        <p
          >In the above code, we created an instance of the
          <code>Person</code> class and assigned it to the variable
          <code>p</code>. We passed in the arguments "John" and 30 to initialize
          the <code>name</code> and <code>age</code> attributes.</p
        >
        <p
          >We can access the attributes and methods of an object using the dot
          notation:</p
        >
        <pre class="language-python">
<code>print(p.name)
      print(p.age)
      p.greet()</code></pre>
        <p
          >In the above code, we accessed the <code>name</code> and
          <code>age</code> attributes of the <code>p</code> object and called
          the <code>greet</code> method.</p
        >
        <p
          >Creating classes is an essential part of object-oriented programming
          in Python. It allows you to create complex data structures with
          attributes and methods that can be reused and shared across multiple
          instances of the class.</p
        >
      </article>
      <article>
        <h2>03- Constructors</h2>
        <p
          >A constructor is a special method that gets called when an object of
          a class is created. It is used to initialize the attributes of the
          object. In Python, the constructor method is called
          <code>__init__</code>.</p
        >
        <p>Let's modify our <code>Person</code> class to use a constructor:</p>
        <pre class="language-python">
<code>class Person:
          def __init__(self, name, age):
              self.name = name
              self.age = age
      
          def greet(self):
              print(f"Hello, my name is {self.name} and I am {self.age} years old.")</code></pre>
        <p
          >In the above code, we defined a constructor method using the
          <code>__init__</code> method. The <code>self</code> parameter is a
          reference to the object being created, and the <code>name</code> and
          <code>age</code> parameters are used to initialize the attributes of
          the object.</p
        >
        <p
          >To create an instance of the <code>Person</code> class, we call the
          class like a function and pass in the required arguments:</p
        >
        <pre class="language-python">
<code>p = Person("John", 30)</code></pre>
        <p
          >In the above code, we created an instance of the
          <code>Person</code> class and assigned it to the variable
          <code>p</code>. We passed in the arguments "John" and 30 to initialize
          the <code>name</code> and <code>age</code> attributes.</p
        >
        <p
          >We can access the attributes and methods of an object using the dot
          notation:</p
        >
        <pre class="language-python">
<code>print(p.name)
      print(p.age)
      p.greet()</code></pre>
        <p
          >In the above code, we accessed the <code>name</code> and
          <code>age</code> attributes of the <code>p</code> object and called
          the <code>greet</code> method.</p
        >
        <p
          >The constructor method allows us to initialize the attributes of an
          object at the time of creation. This makes our code more concise and
          easier to read.</p
        >
      </article>
      <article>
        <h2>04- Class vs Instance Attributes</h2>
        <p
          >In Python, we can define attributes at the class level and the
          instance level. Class attributes are shared by all instances of the
          class, while instance attributes are unique to each instance.</p
        >
        <p>Let's see an example:</p>
        <pre class="language-python">
<code>class Person:
          species = "human" # class attribute
      
          def __init__(self, name, age):
              self.name = name # instance attribute
              self.age = age # instance attribute
      
          def greet(self):
              print(f"Hello, my name is {self.name} and I am {self.age} years old. I am a {self.species}.")
      
      john = Person("John", 30)
      jane = Person("Jane", 25)
      
      john.greet() # Output: Hello, my name is John and I am 30 years old. I am a human.
      jane.greet() # Output: Hello, my name is Jane and I am 25 years old. I am a human.</code></pre>
        <p
          >In the above code, we defined a class attribute called
          <code>species</code> and two instance attributes called
          <code>name</code> and <code>age</code>.</p
        >
        <p
          >When we created the instances <code>john</code> and
          <code>jane</code>, they inherited the <code>species</code> attribute
          from the class. However, their <code>name</code> and
          <code>age</code> attributes are unique to each instance.</p
        >
        <p
          >We can access the class attribute using the class name or the
          instance name:</p
        >
        <pre class="language-python">
<code>print(Person.species) # Output: human
      print(john.species) # Output: human
      print(jane.species) # Output: human</code></pre>
        <p>We can also change the class attribute using the class name:</p>
        <pre class="language-python">
<code>Person.species = "homo sapiens"
      print(Person.species) # Output: homo sapiens
      print(john.species) # Output: homo sapiens
      print(jane.species) # Output: homo sapiens</code></pre>
        <p
          >However, changing the class attribute using an instance name will
          only affect that instance:</p
        >
        <pre class="language-python">
<code>john.species = "homo erectus"
      print(Person.species) # Output: homo sapiens
      print(john.species) # Output: homo erectus
      print(jane.species) # Output: homo sapiens</code></pre>
        <p
          >In the above code, we changed the <code>species</code> attribute of
          the <code>john</code> instance to "homo erectus", while leaving the
          <code>species</code> attribute of the <code>jane</code> instance and
          the <code>Person</code> class unchanged.</p
        >
      </article>

      <article>
        <h2>05- Class vs Instance Methods</h2>
        <p
          >In Python, we can define methods at the class level and the instance
          level. Class methods are called on the class itself, while instance
          methods are called on the instances of the class.</p
        >
        <p>Let's see an example:</p>
        <pre class="language-python">
<code>class Circle:
    pi = 3.14 # class attribute

    def __init__(self, radius):
        self.radius = radius # instance attribute

    def area(self):
        return Circle.pi * self.radius ** 2 # instance method

    @classmethod
    def set_pi(cls, new_pi):
        cls.pi = new_pi # class method

    @staticmethod
    def circumference(radius):
        return 2 * Circle.pi * radius # static method

circle1 = Circle(5)
circle2 = Circle(7)

print(circle1.area()) # Output: 78.5
print(circle2.area()) # Output: 153.86

Circle.set_pi(3.14159)

print(circle1.area()) # Output: 78.53975
print(circle2.area()) # Output: 153.93869

print(Circle.circumference(5)) # Output: 31.4159</code></pre>
        <p
          >In the above code, we defined an instance method called
          <code>area()</code>, a class method called <code>set_pi()</code>, and
          a static method called <code>circumference()</code>.</p
        >
        <p
          >The <code>area()</code> method is called on instances of the
          <code>Circle</code> class, and it uses the instance attribute
          <code>radius</code> and the class attribute <code>pi</code> to
          calculate the area of the circle.</p
        >
        <p
          >The <code>set_pi()</code> method is called on the class itself, and
          it changes the value of the class attribute <code>pi</code>. This
          affects all instances of the class, including those that have already
          been created.</p
        >
        <p
          >The <code>circumference()</code> method is a static method, which
          means it doesn't access any instance or class attributes. It takes a
          radius as an argument and calculates the circumference of the circle
          using the class attribute <code>pi</code>.</p
        >
        <p>We can call these methods using instance names or class names:</p>
        <pre
          class="language-python"
        ><code>print(circle1.area()) # Output: 78.53975
print(circle2.area()) # Output: 153.93869

circle1.set_pi(3.1415)

print(circle1.area()) # Output: 78.53975
print(circle2.area()) # Output: 153.93869

print(Circle.circumference(5)) # Output: 31.415</code></pre>
        <p
          >In the above code, we called the <code>area()</code> method using
          instance names and the <code>set_pi()</code> method and
          <code>circumference()</code> method using the class name.</p
        >
      </article>
      <article>
        <h2>06- Magic Methods</h2>
        <p
          >In Python, magic methods are special methods that start and end with
          double underscores (also called dunder methods) and they are used to
          define how objects of a class behave in certain situations. For
          example, how they are initialized, how they are compared, how they are
          added, etc.</p
        >
        <p>Here are some commonly used magic methods:</p>
        <ul>
          <li
            ><code>__init__(self, ...)</code>: Initializes an instance of the
            class.</li
          >
          <li
            ><code>__str__(self)</code>: Defines the string representation of an
            instance of the class.</li
          >
          <li
            ><code>__eq__(self, other)</code>: Defines how instances of the
            class are compared for equality.</li
          >
          <li
            ><code>__add__(self, other)</code>: Defines how instances of the
            class are added together.</li
          >
          <li
            ><code>__len__(self)</code>: Defines the length of an instance of
            the class.</li
          >
        </ul>
        <p
          >Here is an example of a class that defines some of these magic
          methods:</p
        >
        <pre class="language-python">
<code>class Person:
          def __init__(self, name, age):
              self.name = name
              self.age = age
      
          def __str__(self):
              return f"{self.name} ({self.age})"
      
          def __eq__(self, other):
              return self.age == other.age
      
          def __add__(self, other):
              return Person(f"{self.name} {other.name}", self.age + other.age)
      
          def __len__(self):
              return self.age
      
      person1 = Person("Alice", 25)
      person2 = Person("Bob", 30)
      
      print(person1) # Output: Alice (25)
      print(person1 == person2) # Output: False
      
      person3 = person1 + person2
      print(person3) # Output: Alice Bob (55)
      
      print(len(person1)) # Output: 25</code></pre>
        <p
          >In the above code, we defined a class called <code>Person</code> and
          we defined the <code>__init__()</code> method to initialize instances
          of the class. We also defined the <code>__str__()</code> method to
          define the string representation of the instances, the
          <code>__eq__()</code> method to compare instances for equality, the
          <code>__add__()</code> method to add instances together, and the
          <code>__len__()</code> method to define the length of instances.</p
        >
        <p
          >We can use these magic methods by calling them on instances of the
          class:</p
        >
        <pre class="language-python">
<code>print(person1) # Output: Alice (25)
      print(person1 == person2) # Output: False
      
      person3 = person1 + person2
      print(person3) # Output: Alice Bob (55)
      
      print(len(person1)) # Output: 25</code></pre>
        <p
          >In the above code, we called the <code>__str__()</code> method to
          print the string representation of an instance, the
          <code>__eq__()</code> method to compare two instances for equality,
          the <code>__add__()</code> method to add two instances together, and
          the <code>__len__()</code> method to get the length of an instance.</p
        >
      </article>
      <article>
        <h2>07- Comparing Objects</h2>
        <p
          >In Python, objects of a class can be compared using the
          <code>__eq__()</code> method, which is a magic method that defines how
          two instances of the class are compared for equality.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>class Person:
          def __init__(self, name, age):
              self.name = name
              self.age = age
      
          def __eq__(self, other):
              return self.name == other.name and self.age == other.age
      
      person1 = Person("Alice", 25)
      person2 = Person("Alice", 25)
      person3 = Person("Bob", 30)
      
      print(person1 == person2) # Output: True
      print(person1 == person3) # Output: False</code></pre>
        <p
          >In the above code, we defined a class called <code>Person</code> and
          we defined the <code>__eq__()</code> method to compare instances for
          equality based on the <code>name</code> and
          <code>age</code> attributes.</p
        >
        <p
          >We can compare instances of the class using the
          <code>==</code> operator, which calls the
          <code>__eq__()</code> method:</p
        >
        <pre
          class="language-python"
        ><code>print(person1 == person2) # Output: True
      print(person1 == person3) # Output: False</code></pre>
        <p
          >In the above code, we compare two instances of the
          <code>Person</code> class and get a boolean result based on whether
          they are equal or not.</p
        >
        <p
          >We can also compare instances of a class using other comparison
          operators, such as <code>&lt;</code>, <code>&gt;</code>,
          <code>&lt;=</code>, and <code>&gt;=</code>, by defining the
          corresponding magic methods, such as <code>__lt__()</code>,
          <code>__gt__()</code>, <code>__le__()</code>, and
          <code>__ge__()</code>.</p
        >
      </article>
      <article>
        <h2>08- Performing Arithmetic Operations</h2>
        <p
          >In Python, we can define magic methods to perform arithmetic
          operations on instances of a class. For example, we can define the
          <code>__add__()</code> method to add two instances, the
          <code>__sub__()</code> method to subtract two instances, and so on.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>class Vector:
          def __init__(self, x, y):
              self.x = x
              self.y = y
      
          def __add__(self, other):
              return Vector(self.x + other.x, self.y + other.y)
      
          def __sub__(self, other):
              return Vector(self.x - other.x, self.y - other.y)
      
          def __mul__(self, scalar):
              return Vector(self.x * scalar, self.y * scalar)
      
      vector1 = Vector(1, 2)
      vector2 = Vector(3, 4)
      
      vector3 = vector1 + vector2
      vector4 = vector1 - vector2
      vector5 = vector1 * 2
      
      print(vector3.x, vector3.y) # Output: 4 6
      print(vector4.x, vector4.y) # Output: -2 -2
      print(vector5.x, vector5.y) # Output: 2 4</code></pre>
        <p
          >In the above code, we defined a class called <code>Vector</code> and
          defined the <code>__add__()</code>, <code>__sub__()</code>, and
          <code>__mul__()</code> methods to perform addition, subtraction, and
          scalar multiplication, respectively.</p
        >
        <p
          >We can use the defined operators, such as <code>+</code>,
          <code>-</code>, and <code>*</code>, to perform the corresponding
          operations on instances of the class:</p
        >
        <pre class="language-python">
<code>vector1 = Vector(1, 2)
      vector2 = Vector(3, 4)
      
      vector3 = vector1 + vector2
      vector4 = vector1 - vector2
      vector5 = vector1 * 2
      
      print(vector3.x, vector3.y) # Output: 4 6
      print(vector4.x, vector4.y) # Output: -2 -2
      print(vector5.x, vector5.y) # Output: 2 4</code></pre>
        <p
          >In the above code, we perform addition, subtraction, and scalar
          multiplication on instances of the <code>Vector</code> class using the
          <code>+</code>, <code>-</code>, and <code>*</code> operators,
          respectively.</p
        >
      </article>
      <article>
        <h2>09- Making Custom Containers</h2>
        <p
          >In Python, we can create our own custom container classes by defining
          magic methods that define the behavior of the container. By doing so,
          we can customize the behavior of the container class and make it
          behave like any other built-in container class such as a list or a
          dictionary.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>class MyList:
          def __init__(self):
              self.data = []
      
          def __getitem__(self, index):
              return self.data[index]
      
          def __setitem__(self, index, value):
              self.data[index] = value
      
          def __len__(self):
              return len(self.data)
      
      mylist = MyList()
      mylist.append(1)
      mylist.append(2)
      mylist.append(3)
      
      print(mylist[0]) # Output: 1
      print(mylist[1]) # Output: 2
      print(mylist[2]) # Output: 3
      print(len(mylist)) # Output: 3</code></pre>
        <p
          >In the above code, we defined a class called <code>MyList</code> and
          defined the <code>__getitem__()</code>, <code>__setitem__()</code>,
          and <code>__len__()</code> methods to customize the behavior of the
          class.</p
        >
        <p
          >The <code>__getitem__()</code> method allows us to use the square
          bracket notation to access elements in the list. The
          <code>__setitem__()</code> method allows us to set the value of an
          element in the list. The <code>__len__()</code> method allows us to
          use the <code>len()</code> function to get the length of the list.</p
        >
        <p
          >We can use the custom container class just like any other built-in
          container class:</p
        >
        <pre class="language-python">
<code>mylist = MyList()
      mylist.append(1)
      mylist.append(2)
      mylist.append(3)
      
      print(mylist[0]) # Output: 1
      print(mylist[1]) # Output: 2
      print(mylist[2]) # Output: 3
      print(len(mylist)) # Output: 3</code></pre>
        <p
          >In the above code, we create an instance of the
          <code>MyList</code> class and append elements to it using the
          <code>append()</code> method. We can then access elements in the list
          using the square bracket notation and get the length of the list using
          the <code>len()</code> function.</p
        >
      </article>
      <article>
        <h2>10- Private Members</h2>
        <p
          >In Python, we can create private members in a class by prefixing the
          name of the member with a double underscore (__). Private members
          cannot be accessed from outside the class.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>class MyClass:
          def __init__(self):
              self.__private_member = 0
      
          def __private_method(self):
              print("This is a private method.")
      
          def public_method(self):
              print("This is a public method.")
              self.__private_method()
      
      my_object = MyClass()
      my_object.public_method()
      
      # Accessing private member
      print(my_object.__private_member) # This will raise an AttributeError
      
      # Accessing private method
      my_object.__private_method() # This will raise an AttributeError</code></pre>
        <p
          >In the above code, we defined a class called
          <code>MyClass</code> with a private member
          <code>__private_member</code> and a private method
          <code>__private_method()</code>. We also defined a public method
          called <code>public_method()</code> that can access the private member
          and method.</p
        >
        <p
          >We then created an instance of the class and called the
          <code>public_method()</code> method which calls the private method. We
          cannot access the private member and method from outside the class,
          and attempting to do so will raise an <code>AttributeError</code>.</p
        >
        <p
          >It is important to note that private members in Python are not truly
          private and can still be accessed by name mangling. Name mangling is
          the process of changing the name of the private member by adding a
          prefix of _classname to it. However, it is generally considered bad
          practice to access private members this way and should be avoided.</p
        >
      </article>

      <article>
        <h2>11- Properties</h2>
        <p
          >Properties in Python provide a way to customize the access and
          modification of class attributes. They allow us to define getters and
          setters for our class attributes, making our code more readable and
          maintainable. Properties are defined using the
          <code>@property</code> decorator for the getter method and the
          <code>@&lt;attribute_name&gt;.setter</code> decorator for the setter
          method.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height

    @property
    def width(self):
        return self._width

    @width.setter
    def width(self, value):
        if value <= 0:
            raise ValueError("Width must be positive.")
        self._width = value

    @property
    def height(self):
        return self._height

    @height.setter
    def height(self, value):
        if value <= 0:
            raise ValueError("Height must be positive.")
        self._height = value

    def area(self):
        return self._width * self._height

rectangle = Rectangle(5, 3)
print(rectangle.area()) # Output: 15

rectangle.width = 10
rectangle.height = 6
print(rectangle.area()) # Output: 60</code></pre>
        <p
          >In the above code, we defined a class called
          <code>Rectangle</code> with private attributes <code>_width</code> and
          <code>_height</code>. We then defined getter and setter methods for
          each attribute using the <code>@property</code> and
          <code>@&lt;attribute_name&gt;.setter</code> decorators.</p
        >
        <p
          >These methods allow us to get and set the values of the attributes
          while also performing validation. For example, if we attempt to set
          the width or height to a negative value, a <code>ValueError</code> is
          raised.</p
        >
        <p
          >We also defined a method called <code>area()</code> that returns the
          area of the rectangle by multiplying the width and height. We then
          created an instance of the class and set the values of the width and
          height attributes using the setters. Finally, we called the
          <code>area()</code> method to calculate and print the area of the
          rectangle.</p
        >
      </article>
      <article>
        <h2>12- Inheritance</h2>
        <p
          >Inheritance is a mechanism that allows us to define a new class based
          on an existing class. The new class is called the <em>subclass</em>,
          and the existing class is called the <em>superclass</em>.</p
        >
        <p
          >When a subclass is created, it inherits all the attributes and
          methods of the superclass. This means that the subclass can use and
          override these attributes and methods as needed.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>class Animal:
    def __init__(self, name):
        self._name = name

    def speak(self):
        raise NotImplementedError("Subclass must implement abstract method")

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

dog = Dog("Rufus")
print(dog.speak()) # Output: Woof!

cat = Cat("Misty")
print(cat.speak()) # Output: Meow!</code></pre>
        <p
          >In the above code, we defined a class called <code>Animal</code> with
          an attribute called <code>_name</code> and a method called
          <code>speak()</code>. The <code>speak()</code> method is declared as
          an abstract method using the
          <code>NotImplementedError</code> exception.</p
        >
        <p
          >We then defined two subclasses called <code>Dog</code> and
          <code>Cat</code>. These subclasses inherit from the
          <code>Animal</code> superclass and override the
          <code>speak()</code> method to return the appropriate sound.</p
        >
        <p
          >We then created instances of the <code>Dog</code> and
          <code>Cat</code> classes and called their <code>speak()</code> methods
          to print out the sound they make.</p
        >
        <p
          >Inheritance is a powerful feature of object-oriented programming that
          allows us to create complex class hierarchies and reuse code
          effectively. However, it should be used carefully to avoid creating
          overly complex and tightly coupled code.</p
        >
      </article>
      <article>
        <h2>13- The Object Class</h2>
        <p
          >In Python, everything is an object. All classes inherit from the
          <code>object</code> class, which is the root of the class hierarchy.
          This means that all objects in Python have some common attributes and
          methods provided by the <code>object</code> class.</p
        >
        <p
          >For example, all objects in Python have a method called
          <code>__str__()</code>, which is used to convert the object to a
          string representation. The default implementation of this method
          provided by the <code>object</code> class returns a string like
          &lt;__main__.MyClass object at 0x7f878f7d4c88&gt;. However, we can
          override this method in our own classes to provide a more meaningful
          string representation of our objects.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>class Person:
          def __init__(self, name, age):
              self._name = name
              self._age = age
      
          def __str__(self):
              return f"{self._name} ({self._age} years old)"
      
      person = Person("Alice", 30)
      print(person) # Output: Alice (30 years old)</code></pre>
        <p
          >In the above code, we defined a class called <code>Person</code> with
          two attributes called <code>_name</code> and <code>_age</code>, and a
          method called <code>__str__()</code> which returns a string
          representation of the object.</p
        >
        <p
          >We then created an instance of the <code>Person</code> class and
          printed it using the <code>print()</code> function. Since we have
          overridden the <code>__str__()</code> method, the output is a more
          meaningful representation of the object.</p
        >
        <p
          >By inheriting from the <code>object</code> class, we also get access
          to other common methods like <code>__eq__()</code>,
          <code>__hash__()</code>, and <code>__repr__()</code>, which we can
          override in our own classes as needed.</p
        >
      </article>
      <article>
        <h2>14- Method Overriding</h2>
        <p
          >In Python, method overriding allows a subclass to provide a different
          implementation of a method that is already defined in its superclass.
          When a method is called on an object of the subclass, the
          implementation provided by the subclass is used instead of the
          implementation provided by the superclass.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>class Animal:
          def sound(self):
              print("The animal makes a sound")
      
      class Cat(Animal):
          def sound(self):
              print("Meow")
      
      cat = Cat()
      cat.sound() # Output: Meow</code></pre>
        <p
          >In the above code, we defined a superclass called
          <code>Animal</code> with a method called <code>sound()</code> which
          prints a message indicating that the animal makes a sound.</p
        >
        <p
          >We then defined a subclass called <code>Cat</code> which inherits
          from the <code>Animal</code> class and overrides the
          <code>sound()</code> method to print "Meow" instead.</p
        >
        <p
          >We created an instance of the <code>Cat</code> class and called the
          <code>sound()</code> method on it. Since the <code>Cat</code> class
          overrides the <code>sound()</code> method, the output is "Meow".</p
        >
        <p
          >Note that when a subclass overrides a method of its superclass, it
          can still call the implementation of the superclass by calling the
          method on the superclass itself using the
          <code>super()</code> function.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>class Animal:
          def sound(self):
              print("The animal makes a sound")
      
      class Cat(Animal):
          def sound(self):
              super().sound()
              print("Meow")
      
      cat = Cat()
      cat.sound() # Output: The animal makes a sound Meow</code></pre>
        <p
          >In the above code, we defined the same <code>Animal</code> and
          <code>Cat</code> classes as before. However, in the
          <code>Cat</code> class, we added a call to the
          <code>sound()</code> method of the <code>Animal</code> class using the
          <code>super()</code> function.</p
        >
        <p
          >When we create an instance of the <code>Cat</code> class and call the
          <code>sound()</code> method on it, both the implementation of the
          <code>Cat</code> class and the <code>Animal</code> class are executed.
          The output is "The animal makes a sound" followed by "Meow".</p
        >
      </article>
      <article>
        <h2>15- Multi-level Inheritance</h2>
        <p
          >In Python, it is possible to create a subclass that inherits from
          another subclass. This is called multi-level inheritance.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>class Animal:
          def sound(self):
              print("The animal makes a sound")
      
      class Mammal(Animal):
          def feed_milk(self):
              print("The mammal feeds milk")
      
      class Cat(Mammal):
          def sound(self):
              print("Meow")
      
      cat = Cat()
      cat.feed_milk() # Output: The mammal feeds milk
      cat.sound() # Output: Meow</code></pre>
        <p
          >In the above code, we defined a superclass called
          <code>Animal</code> with a method called <code>sound()</code> which
          prints a message indicating that the animal makes a sound. We then
          defined a subclass called <code>Mammal</code> which inherits from the
          <code>Animal</code> class and adds a method called
          <code>feed_milk()</code> which prints a message indicating that the
          mammal feeds milk.</p
        >
        <p
          >We then defined a subclass called <code>Cat</code> which inherits
          from the <code>Mammal</code> class and overrides the
          <code>sound()</code> method to print "Meow" instead.</p
        >
        <p
          >We created an instance of the <code>Cat</code> class and called the
          <code>feed_milk()</code> and <code>sound()</code> methods on it. Since
          the <code>Cat</code> class inherits from the
          <code>Mammal</code> class, which inherits from the
          <code>Animal</code> class, it has access to the methods of both
          superclasses. Therefore, the output is "The mammal feeds milk"
          followed by "Meow".</p
        >
      </article>
      <article>
        <h2>16- Multiple Inheritance</h2>
        <p
          >In Python, it is possible to create a subclass that inherits from
          multiple superclasses. This is called multiple inheritance.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>class Animal:
          def sound(self):
              print("The animal makes a sound")
      
      class Mammal(Animal):
          def feed_milk(self):
              print("The mammal feeds milk")
      
      class Bird(Animal):
          def fly(self):
              print("The bird can fly")
      
      class Bat(Mammal, Bird):
          def sound(self):
              print("Screech")
      
      bat = Bat()
      bat.feed_milk() # Output: The mammal feeds milk
      bat.fly() # Output: The bird can fly
      bat.sound() # Output: Screech</code></pre>
        <p
          >In the above code, we defined two superclasses called
          <code>Animal</code> and <code>Bird</code> with methods called
          <code>sound()</code> and <code>fly()</code>, respectively. We then
          defined two subclasses called <code>Mammal</code> and
          <code>Bat</code> which inherit from the <code>Animal</code> class, and
          a subclass called <code>Bat</code> which inherits from both the
          <code>Mammal</code> and <code>Bird</code> classes.</p
        >
        <p
          >We created an instance of the <code>Bat</code> class and called the
          <code>feed_milk()</code>, <code>fly()</code>, and
          <code>sound()</code> methods on it. Since the <code>Bat</code> class
          inherits from both the <code>Mammal</code> and
          <code>Bird</code> classes, it has access to the methods of both
          superclasses. Therefore, the output is "The mammal feeds milk"
          followed by "The bird can fly" and "Screech".</p
        >
        <p
          >Note that if there are two superclasses with the same method name,
          the method from the first superclass listed in the inheritance list
          will be used.</p
        >
      </article>
      <article>
        <h2>17- A Good Example of Inheritance</h2>
        <p
          >Inheritance is a powerful feature of object-oriented programming that
          allows code reuse and enables the creation of more specialized classes
          from existing classes.</p
        >
        <p
          >One good example of inheritance is the use of a
          <code>Vehicle</code> class as a base class, with more specialized
          classes such as <code>Car</code>, <code>Truck</code>, and
          <code>Motorcycle</code> inheriting from it. The
          <code>Vehicle</code> class contains general attributes and methods
          that are common to all types of vehicles, while the specialized
          classes add their own attributes and methods to the inherited ones.</p
        >
        <p>Here is an example:</p>
        <pre class="language-python">
<code>class Vehicle:
          def __init__(self, make, model, year):
              self.make = make
              self.model = model
              self.year = year
              self.weight = None
              self.color = None
      
          def start(self):
              print("Starting the vehicle")
      
          def stop(self):
              print("Stopping the vehicle")
      
      class Car(Vehicle):
          def __init__(self, make, model, year, num_doors):
              super().__init__(make, model, year)
              self.num_doors = num_doors
      
          def start(self):
              print("Starting the car")
      
          def drive(self):
              print("Driving the car")
      
      class Truck(Vehicle):
          def __init__(self, make, model, year, payload_capacity):
              super().__init__(make, model, year)
              self.payload_capacity = payload_capacity
      
          def start(self):
              print("Starting the truck")
      
          def load(self):
              print("Loading the truck")
      
      class Motorcycle(Vehicle):
          def __init__(self, make, model, year, has_sidecar):
              super().__init__(make, model, year)
              self.has_sidecar = has_sidecar
      
          def start(self):
              print("Starting the motorcycle")
      
          def ride(self):
              print("Riding the motorcycle")</code></pre>
        <p
          >In the above code, we defined a base class called
          <code>Vehicle</code> that contains the attributes and methods that are
          common to all types of vehicles, such as make, model, year, weight,
          and color. We then defined three subclasses called <code>Car</code>,
          <code>Truck</code>, and <code>Motorcycle</code> that inherit from the
          <code>Vehicle</code> class and add their own attributes and
          methods.</p
        >
        <p
          >The <code>Car</code> class adds the <code>num_doors</code> attribute
          and the <code>drive()</code> method, the <code>Truck</code> class adds
          the <code>payload_capacity</code> attribute and the
          <code>load()</code> method, and the <code>Motorcycle</code> class adds
          the <code>has_sidecar</code> attribute and the
          <code>ride()</code> method.</p
        >
        <p
          >Each subclass also overrides the <code>start()</code> method to
          provide a more specific implementation for starting the vehicle.</p
        >
        <p
          >The use of inheritance in this example allows us to reuse the code in
          the <code>Vehicle</code> class and add more specific behavior to the
          subclasses without duplicating the common code. It also makes the code
          easier to read and maintain by grouping related functionality
          together.</p
        >
      </article>
      <article>
        <h2>18- Abstract Base Classes</h2>
        <p>
          Abstract Base Classes (ABCs) are a way to define abstract classes in
          Python. An abstract class is a class that is meant to be subclassed,
          but not instantiated. Abstract classes cannot be instantiated because
          they have at least one abstract method, which is a method declared but
          not implemented in the abstract class.
        </p>
        <p>
          In Python, the abc module provides the infrastructure for defining
          abstract base classes. You can define an abstract base class by
          subclassing the ABC class from the abc module. You can then define
          abstract methods by using the @abstractmethod decorator. When a
          subclass of an abstract base class is defined, it must implement all
          abstract methods declared in the abstract base class.
        </p>
        <pre class="language-python">
<code>
      from abc import ABC, abstractmethod
      class Animal(ABC):
      @abstractmethod
      def move(self):
      pass
      
      class Dog(Animal):
      def move(self):
      print("Dog is moving by running")
      
      dog = Dog()
      dog.move()
      </code></pre>

        <p>
          In the example above, we define an abstract base class called Animal
          that has an abstract method move(). We then define a subclass of
          Animal called Dog that implements the move() method. Finally, we
          create an instance of Dog and call the move() method on it, which
          prints "Dog is moving by running" to the console.
        </p>
        <p>
          Abstract base classes can be useful for enforcing a common interface
          among different classes that do not share a common base class. They
          can also be useful for defining a "template" for a class hierarchy,
          where the abstract base class provides some default behavior and
          concrete subclasses provide more specialized behavior.
        </p>
        <p>
          Note that in Python, abstract base classes are not strictly enforced.
          It is still possible to instantiate an abstract base class or to
          define a subclass that does not implement all abstract methods.
          However, using abstract base classes can help to make your code more
          clear and robust.
        </p>
      </article>
      <article>
        <h2>19- Polymorphism</h2>
        <p>
          Polymorphism is the ability of an object to take on many forms. In
          Python, polymorphism is achieved through method overriding and duck
          typing.
        </p>
        <p>
          Method overriding is when a subclass provides a different
          implementation for a method that is already defined in its superclass.
          When a method is called on an object of the subclass, the overridden
          method is called instead of the method defined in the superclass. This
          allows for different behavior to be implemented for objects of
          different classes that share a common interface.
        </p>
        <pre class="language-python">
<code>
      class Animal:
          def move(self):
              print("Animal is moving")
      class Dog(Animal):
      def move(self):
      print("Dog is running")
      
      class Bird(Animal):
      def move(self):
      print("Bird is flying")
      
      animals = [Dog(), Bird()]
      for animal in animals:
      animal.move()
      </code></pre>

        <p>
          In the example above, we define an abstract base class called Animal
          that has a method move(). We then define two concrete subclasses of
          Animal called Dog and Bird that override the move() method with their
          own implementations. Finally, we create a list of animals that
          contains instances of both Dog and Bird, and call the move() method on
          each animal in the list. The output of the program is:
        </p>
        <pre class="language-python">
<code>
      Dog is running
      Bird is flying
        </code></pre>
        <p>
          Duck typing is another form of polymorphism in Python. It is based on
          the principle that if an object walks like a duck and quacks like a
          duck, it must be a duck. In other words, if an object has the
          necessary attributes and methods to perform a certain task, it can be
          used in place of another object that is expected to perform the same
          task, regardless of its type.
        </p>
        <pre class="language-python">
<code>
      class Car:
          def drive(self):
              print("Driving a car")
      class Bike:
      def drive(self):
      print("Riding a bike")
      
      def drive_vehicle(vehicle):
      vehicle.drive()
      
      car = Car()
      bike = Bike()
      
      drive_vehicle(car)
      drive_vehicle(bike)
      </code></pre>

        <p>
          In the example above, we define two classes Car and Bike that have a
          method called drive(). We then define a function called
          drive_vehicle() that takes an object as an argument and calls its
          drive() method. Finally, we create instances of both Car and Bike and
          pass them as arguments to the drive_vehicle() function. The output of
          the program is:
        </p>
        <pre class="language-python">
<code>
      Driving a car
      Riding a bike
        </code></pre>
        <p>
          As you can see, the drive_vehicle() function can take either a Car
          object or a Bike object as an argument, as long as the object has a
          drive() method. This is an example of duck typing in action.
        </p>
      </article>
      <article>
        <h2>Duck Typing</h2>
        <p
          >In Python, Duck Typing is a programming concept that allows you to
          use an object based on its behavior rather than its class. The idea is
          that if an object looks like a duck, swims like a duck, and quacks
          like a duck, then it's probably a duck, or in other words, if an
          object implements a set of methods that are required for a particular
          operation, then that object can be used in place of any other object
          that has the same methods.</p
        >
        <p
          >For example, if we have a function that expects an object to have a
          method called 'fly', we can pass in any object that has a 'fly'
          method, regardless of its class. This allows for greater flexibility
          in designing and using code, and is a key feature of Python's dynamic
          typing system.</p
        >
        <pre class="language-python">
<code>class Bird:
            def fly(self):
                print("The bird is flying")
        class Airplane:
        def fly(self):
        print("The airplane is flying")
        
        class Bat:
        def fly(self):
        print("The bat is flying")
        
        def make_object_fly(obj):
        obj.fly()
        
        bird = Bird()
        airplane = Airplane()
        bat = Bat()
        
        make_object_fly(bird) # The bird is flying
        make_object_fly(airplane) # The airplane is flying
        make_object_fly(bat) # The bat is flying
        </code></pre>

        <p
          >In the above example, we define three classes, Bird, Airplane, and
          Bat, each with a 'fly' method. We then define a function called
          'make_object_fly' that takes an object as an argument and calls its
          'fly' method. We can then create instances of each class and pass them
          to the 'make_object_fly' function. Since each object has a 'fly'
          method, the function can be used with any of them.</p
        >
      </article>
      <article>
        <h2>Extending Built-in Types</h2>
        <p
          >In Python, it is possible to extend the behavior of built-in types
          such as lists, dictionaries, and strings by defining new methods on
          them. This can be useful if you have a specific use case that is not
          covered by the existing methods.</p
        >
        <p
          >For example, let's say we want to add a new method to the list class
          that returns the sum of all the even numbers in the list:</p
        >
        <pre class="language-python">
<code>class MyList(list):
            def even_sum(self):
                return sum(x for x in self if x % 2 == 0)
        my_list = MyList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
        print(my_list.even_sum()) # Output: 30
        </code></pre>

        <p
          >In the above example, we define a new class called 'MyList' that
          inherits from the built-in list class. We then define a new method
          called 'even_sum' that returns the sum of all the even numbers in the
          list. We can then create an instance of 'MyList' and call the
          'even_sum' method on it.</p
        >
        <p
          >Extending built-in types can be a powerful tool, but it should be
          used with caution. It can make code harder to read and understand, and
          it can also cause conflicts with other code that relies on the
          built-in behavior of the type.</p
        >
      </article>
      <article>
        <h2>Data Classes</h2>
        <p
          >In Python 3.7 and later versions, there is a built-in decorator
          called <code>@dataclass</code> that allows you to quickly create
          classes that are mainly used to store data. A data class is a class
          that contains only attributes, with no methods or logic.</p
        >
        <p
          >The <code>@dataclass</code> decorator automatically generates several
          special methods, such as <code>__init__</code>, <code>__repr__</code>,
          and <code>__eq__</code>, based on the attributes defined in the class.
          This can save a lot of boilerplate code that would otherwise be
          required to define these methods manually.</p
        >
        <p>Here is an example of a simple data class:</p>
        <pre class="language-python">
<code>from dataclasses import dataclass
        @dataclass
        class Point:
        x: float
        y: float
        
        p = Point(1.5, 2.5)
        print(p) # Output: Point(x=1.5, y=2.5)
        </code></pre>

        <p
          >In the above example, we define a data class called 'Point' that has
          two attributes: 'x' and 'y'. We then create an instance of the 'Point'
          class and print it, which shows that the <code>__repr__</code> method
          has been automatically generated to display the values of the
          attributes.</p
        >
        <p
          >By default, all attributes in a data class are considered to be
          mutable. However, you can use the <code>field()</code> function to
          specify different properties for each attribute, such as making it
          immutable or specifying a default value:</p
        >
        <pre
          class="language-python"
        ><code>from dataclasses import dataclass, field
        @dataclass
        class Person:
        name: str
        age: int = field(default=30)
        email: str = field(default='')
        
        p = Person('Alice')
        print(p.age) # Output: 30
        print(p.email) # Output: ''
        </code></pre>

        <p
          >In the above example, we define a data class called 'Person' that has
          three attributes: 'name', 'age', and 'email'. We use the
          <code>field()</code> function to specify a default value of 30 for the
          'age' attribute and an empty string for the 'email' attribute.</p
        >
        <p
          >Data classes are a convenient way to define simple classes that are
          primarily used to store data. They can save a lot of boilerplate code
          and make the code more readable and maintainable.</p
        >
      </article>
      <h2 class="a-main-topic">08 Modules</h2>
      <article>
        <h2>01- Creating Modules</h2>
        <p
          >In Python, a module is simply a file containing Python definitions
          and statements. The file name is the module name with the suffix .py.
          To use the module, you have to import it using the
          <span>import</span> statement.
        </p>
        <p>Here is an example of how to create a module:</p>
        <pre class="language-python">
<code>
        # Create a file named my_module.py
      def greet(name):
      print("Hello, " + name)
      
      def add_numbers(num1, num2):
      return num1 + num2
      </code></pre>

        <p
          >Now, to use this module in another Python file, you can import it
          using the <span>import</span> statement:</p
        >
        <pre class="language-python">
<code>
        # Importing my_module.py
      import my_module
      
      my_module.greet("John") # Output: Hello, John
      
      sum = my_module.add_numbers(10, 20)
      print(sum) # Output: 30
      </code></pre>

        <p
          >In the above example, we have created a module called my_module.py
          with two functions greet() and add_numbers(). We then imported the
          my_module.py file in another Python file and used the functions
          defined in it.</p
        >
      </article>
      <article>
        <h2>02- Compiled Python Files</h2>
        <p
          >When you import a module, Python first searches for the module in the
          current directory, and then in the list of directories defined in the
          <span>sys.path</span> variable. If the module is found, Python
          compiles the module into a bytecode format to improve the performance
          of the import statement.</p
        >
        <p
          >The compiled bytecode is stored in a file with a .pyc extension. If
          the compiled bytecode file exists and is up-to-date with the
          corresponding .py file, Python will use the .pyc file instead of
          recompiling the .py file. This can speed up the import process.</p
        >
        <p>Here is an example of how to create a compiled bytecode file:</p>
        <pre class="language-python">
<code>
        # Create a file named my_module.py
      def greet(name):
      print("Hello, " + name)
      
      def add_numbers(num1, num2):
      return num1 + num2
      
      # Compile my_module.py into my_module.pyc
      # You don't need to run this command manually, Python will do it automatically when you import the module
      import py_compile
      py_compile.compile("my_module.py")
      </code></pre>

        <p
          >Now, when you import the module in another Python file, Python will
          first check for the existence of the my_module.pyc file and use it if
          it's available and up-to-date:</p
        >
        <pre class="language-python">
<code>
        # Importing my_module.py
      import my_module
      
      my_module.greet("John") # Output: Hello, John
      
      sum = my_module.add_numbers(10, 20)
      print(sum) # Output: 30
      </code></pre>

        <p
          >By default, Python creates .pyc files in the same directory as the
          corresponding .py files. You can also customize the location of the
          .pyc files by setting the <span>__pycache__</span> directory in the
          <span>sys.path</span> variable.</p
        >
      </article>
      <article>
        <h2>03- Module Search Path</h2>
        <p
          >When you import a module in Python, it searches for the module in a
          predefined search path. The search path is a list of directories
          defined in the <span>sys.path</span> variable.</p
        >
        <p
          >The search path includes the current directory, the Python standard
          library directory, and any additional directories defined by the
          <span>PYTHONPATH</span> environment variable or the
          <span>site</span> module. You can also add directories to the search
          path dynamically using the <span>sys.path.append()</span> method.</p
        >
        <p>To print the current search path, you can use the following code:</p>
        <pre class="language-python">
<code>
        import sys
        print(sys.path)
        </code></pre>
        <p>The output will be a list of directories:</p>
        <pre><code>[
        '',
        '/usr/lib/python39.zip',
        '/usr/lib/python3.9',
        '/usr/lib/python3.9/lib-dynload',
        '/usr/local/lib/python3.9/dist-packages',
        '/usr/lib/python3/dist-packages'
        ]
        </code></pre>
        <p
          >The first element in the list is the current directory. You can add a
          new directory to the search path dynamically using the
          <span>sys.path.append()</span> method:</p
        >
        <pre class="language-python">
<code>
        import sys
        sys.path.append('/path/to/my/module')
      # Now you can import your module
      import my_module
      </code></pre>

        <p
          >In the above example, we added the
          <span>/path/to/my/module</span> directory to the search path and then
          imported the <span>my_module</span> module from that directory.</p
        >
      </article>
      <article>
        <h2>04- Packages</h2>
        <p
          >In Python, a package is a way of organizing related modules and
          sub-packages into a single hierarchy. A package is simply a directory
          that contains one or more Python modules, along with a special file
          called <span>__init__.py</span>, which tells Python that the directory
          should be considered a package.</p
        >
        <p>Here is an example of a package:</p>
        <pre><code>
        my_package/
            __init__.py
            module1.py
            module2.py
            sub_package/
                __init__.py
                module3.py
        </code></pre>
        <p
          >In this example, <span>my_package</span> is a package that contains
          two modules (<span>module1.py</span> and <span>module2.py</span>) and
          a sub-package (<span>sub_package</span>) that contains one module
          (<span>module3.py</span>).</p
        >
        <p>To import a module from a package, you can use the dot notation:</p>
        <pre class="language-python">
<code>
        # Importing module1.py from my_package
      import my_package.module1
      
      my_package.module1.function()
      </code></pre>

        <p
          >You can also use the <span>from ... import</span> statement to import
          a module or function from a package:</p
        >
        <pre class="language-python">
<code>
        # Importing function from module1.py in my_package
      from my_package.module1 import function
      
      function()
      </code></pre>

        <p
          >To import a module from a sub-package, you can use the dot
          notation:</p
        >
        <pre class="language-python">
<code>
        # Importing module3.py from sub_package in my_package
      import my_package.sub_package.module3
      
      my_package.sub_package.module3.function()
      </code></pre>

        <p
          >You can also use the <span>from ... import</span> statement to import
          a module or function from a sub-package:</p
        >
        <pre class="language-python">
<code>
        # Importing function from module3.py in sub_package in my_package
      from my_package.sub_package.module3 import function
      
      function()
      </code></pre>
      </article>

      <article>
        <h2>05- Sub-packages</h2>
        <p
          >In Python, a sub-package is a package that is contained within
          another package. A sub-package is simply a directory that contains one
          or more Python modules, along with a special file called
          <span>__init__.py</span>, which tells Python that the directory should
          be considered a package.</p
        >
        <p>Here is an example of a package with a sub-package:</p>
        <pre><code>
  my_package/
      __init__.py
      module1.py
      module2.py
      sub_package/
          __init__.py
          module3.py
          sub_sub_package/
              __init__.py
              module4.py
  </code></pre>
        <p
          >In this example, <span>my_package</span> is a package that contains
          two modules (<span>module1.py</span> and <span>module2.py</span>), a
          sub-package (<span>sub_package</span>) that contains one module
          (<span>module3.py</span>), and a sub-sub-package
          (<span>sub_sub_package</span>) that contains one module
          (<span>module4.py</span>).</p
        >
        <p
          >To import a module from a sub-package, you can use the dot
          notation:</p
        >
        <pre class="language-python">
<code>
  # Importing module3.py from sub_package in my_package
import my_package.sub_package.module3

my_package.sub_package.module3.function()
</code></pre>

        <p
          >You can also use the <span>from ... import</span> statement to import
          a module or function from a sub-package:</p
        >
        <pre class="language-python">
<code>
  # Importing function from module3.py in sub_package in my_package
from my_package.sub_package.module3 import function

function()
</code></pre>

        <p
          >To import a module from a sub-sub-package, you can use the dot
          notation:</p
        >
        <pre class="language-python">
<code>
  # Importing module4.py from sub_sub_package in sub_package in my_package
import my_package.sub_package.sub_sub_package.module4

my_package.sub_package.sub_sub_package.module4.function()
</code></pre>

        <p
          >You can also use the <span>from ... import</span> statement to import
          a module or function from a sub-sub-package:</p
        >
        <pre class="language-python">
<code>
  # Importing function from module4.py in sub_sub_package in sub_package in my_package
from my_package.sub_package.sub_sub_package.module4 import function

function()
</code></pre>
      </article>
      <article>
        <h2>06- Intra-package References</h2>
        <p
          >In Python, you can use relative imports to refer to other modules or
          sub-packages within the same package. A relative import uses the dot
          notation to specify the location of the module or package relative to
          the current module. Here is an example:</p
        >
        <pre><code>
        my_package/
            __init__.py
            module1.py
            module2.py
            sub_package/
                __init__.py
                module3.py
                sub_sub_package/
                    __init__.py
                    module4.py
        </code></pre>
        <p
          >If you are in <span>module3.py</span> and want to import
          <span>module1.py</span>, you can use the following relative import:</p
        >
        <pre class="language-python">
<code>
        # Importing module1.py from the parent package
      from .. import module1
      
      module1.function()
      </code></pre>

        <p
          >If you are in <span>module4.py</span> and want to import
          <span>module2.py</span>, you can use the following relative import:</p
        >
        <pre class="language-python">
<code>
        # Importing module2.py from the parent package
      from ... import module2
      
      module2.function()
      </code></pre>

        <p
          >Notice that the number of dots in the import statement corresponds to
          the number of levels up in the package hierarchy.</p
        >
        <p
          >You can also use the dot notation to refer to other modules or
          sub-packages within the same package:</p
        >
        <pre class="language-python">
<code>
        # Importing module1.py from the same package
      from . import module1
      
      module1.function()
      
      # Importing module3.py from the sub-package
      from .sub_package import module3
      
      module3.function()
      </code></pre>

        <p
          >Relative imports are particularly useful for intra-package
          references, as they allow you to refer to other modules and
          sub-packages within the same package without having to know the
          absolute path of the package.</p
        >
      </article>
      <article>
        <h2>07- The dir Function</h2>
        <p
          >The <span>dir</span> function is a built-in function in Python that
          returns a list of names in the current local scope or in the specified
          module or object.</p
        >
        <p
          >The <span>dir</span> function can be useful for exploring the
          contents of a module or object, as it returns a list of the names of
          all the variables, functions, classes, and other objects defined in
          the specified module or object.</p
        >
        <p
          >Here is an example of how to use the <span>dir</span> function to
          explore the contents of a module:</p
        >
        <pre class="language-python">
<code>
        import math
      print(dir(math))
      </code></pre>

        <p
          >This will print out a list of the names defined in the
          <span>math</span> module, including functions such as
          <span>sin</span> and <span>cos</span>, and constants such as
          <span>pi</span> and <span>e</span>.</p
        >
        <p
          >You can also use the <span>dir</span> function with objects to see
          the list of attributes and methods defined for that object. Here is an
          example:</p
        >
        <pre class="language-python">
<code>
        class MyClass:
            def __init__(self):
                self.x = 1
                self.y = 2
            def my_method(self):
                print("Hello, World!")

            obj = MyClass()

            print(dir(obj))
                </code></pre>

        <p
          >This will print out a list of the attributes and methods defined for
          the <span>obj</span> instance of the <span>MyClass</span> class,
          including <span>x</span>, <span>y</span>, and
          <span>my_method</span>.</p
        >
        <p
          >The <span>dir</span> function can be a useful tool for understanding
          the contents of a module or object, and for exploring the available
          functionality of a module or object.</p
        >
      </article>
      <article>
        <h2>08- Executing Modules as Scripts</h2>
        <p
          >In Python, modules can be executed as scripts. When a module is
          executed as a script, the code in the module is executed just like any
          other Python code.</p
        >
        <p
          >To execute a module as a script, you can use the following code at
          the bottom of your module:</p
        >
        <pre class="language-python">
<code>
        if __name__ == "__main__":
            # code to be executed when the module is run as a script
        </code></pre>
        <p
          >This code will only be executed if the module is run as a script,
          rather than imported as a module into another Python program. This is
          because the <span>__name__</span> variable is set to
          "<span>__main__</span>" when the module is run as a script, but is set
          to the name of the module when it is imported into another program.</p
        >
        <p>Here is an example of a module that can be executed as a script:</p>
        <pre class="language-python">
<code>
        def hello():
            print("Hello, World!")
      if name == "main":
      hello()
      </code></pre>

        <p
          >When this module is executed as a script, it will print out "Hello,
          World!". However, if this module is imported into another Python
          program, the <span>hello</span> function will be available for use in
          that program, but the code in the
          <span>if __name__ == "__main__"</span> block will not be executed.</p
        >
        <p
          >Executing modules as scripts can be a useful way to test and debug
          code that will eventually be used in other programs, or to create
          small command-line tools.</p
        >
      </article>
      <h2 class="a-main-topic">09 Python Standard Library</h2>
      <article>
        <h2>01- Python Standard Library (introduction)</h2>
        <p>
          Python Standard Library is a collection of modules and packages that
          come with the Python programming language. These modules and packages
          provide various functionalities such as file I/O operations, regular
          expressions, string manipulation, network programming, and much more.
          In this note, we will cover some of the commonly used modules and
          their functionalities.
        </p>
        <p> The following code shows how to import a module in Python: </p>
        <pre class="language-python">
<code>import module_name</code></pre>
        <p>
          Once you import a module, you can access its functions and classes
          using dot notation.
        </p>
        <pre class="language-python">
<code>
      import math
      print(math.pi)  # Output: 3.141592653589793
        </code></pre>
        <p>
          The above code imports the math module and accesses its pi constant
          using dot notation. Here are some of the commonly used modules in
          Python Standard Library:
        </p>
        <ol>
          <li
            ><span>os:</span> provides a way of interacting with the operating
            system.</li
          >
          <li
            ><span>datetime:</span> provides classes for working with dates and
            times.</li
          >
          <li
            ><span>random:</span> provides functions for generating random
            numbers.</li
          >
          <li><span>re:</span> provides support for regular expressions.</li>
          <li
            ><span>json:</span> provides support for working with JSON data.</li
          >
          <li><span>urllib:</span> provides a way to work with URLs.</li>
        </ol>
      </article>
      <article>
        <h2>02- Working With Paths</h2>
        <p>
          The <code>os.path</code> module provides a way to work with file paths
          in a platform-independent way. It automatically adapts to the correct
          path separator for the operating system you are running on, making it
          easy to write cross-platform code.
        </p>
        <p>
          Here's an example of how to use the <code>os.path</code> module to
          join two path components together:
        </p>
        <pre class="language-python">
<code>
      import os
      # Join two path components together
      path = os.path.join('path', 'to', 'file.txt')
      print(path) # Output: path/to/file.txt
      </code></pre>

        <p>
          You can also split a path into its components using the
          <code>os.path.split()</code> function:
        </p>
        <pre class="language-python">
<code>
      import os
      # Split a path into its components
      path = 'path/to/file.txt'
      directory, filename = os.path.split(path)
      print(directory) # Output: path/to
      print(filename) # Output: file.txt
      </code></pre>

        <p>
          The <code>os.path</code> module also provides other functions for
          working with paths, such as <code>os.path.exists()</code> to check if
          a file or directory exists, and <code>os.path.abspath()</code> to get
          the absolute path of a file or directory.
        </p>
        <p> Here's an example of how to use <code>os.path.exists()</code>: </p>
        <pre class="language-python">
<code>
      import os
      # Check if a file exists
      file_path = 'path/to/file.txt'
      if os.path.exists(file_path):
      print('File exists')
      else:
      print('File does not exist')
      </code></pre>

        <p>
          And here's an example of how to use <code>os.path.abspath()</code>:
        </p>
        <pre class="language-python">
<code>
      import os
      # Get the absolute path of a file
      file_path = 'path/to/file.txt'
      absolute_path = os.path.abspath(file_path)
      print(absolute_path)
      </code></pre>
      </article>
      <article>
        <h2>03- Working with Directories</h2>
        <p>
          The <code>os</code> module provides functions for working with
          directories in Python. You can use these functions to create, delete,
          and navigate directories on your file system.
        </p>
        <p>
          Here's an example of how to create a new directory using the
          <code>os.mkdir()</code> function:
        </p>
        <pre class="language-python">
<code>
      import os
      # Create a new directory
      os.mkdir('new_directory')
      </code></pre>

        <p>
          You can also create multiple nested directories at once using the
          <code>os.makedirs()</code> function:
        </p>
        <pre class="language-python">
<code>
      import os
      # Create multiple nested directories
      os.makedirs('parent_directory/child_directory/grandchild_directory')
      </code></pre>

        <p>
          To delete a directory, you can use the
          <code>os.rmdir()</code> function:
        </p>
        <pre class="language-python">
<code>
      import os
      # Delete a directory
      os.rmdir('directory_to_delete')
      </code></pre>

        <p>
          Note that the <code>os.rmdir()</code> function can only be used to
          delete empty directories. If you want to delete a directory and all
          its contents, you can use the <code>shutil.rmtree()</code> function:
        </p>
        <pre class="language-python">
<code>
      import shutil
      # Delete a directory and all its contents
      shutil.rmtree('directory_to_delete')
      </code></pre>

        <p>
          You can also use the <code>os.listdir()</code> function to get a list
          of all the files and directories in a directory:
        </p>
        <pre class="language-python">
<code>
      import os
      # Get a list of all files and directories in a directory
      directory_contents = os.listdir('directory_path')
      print(directory_contents)
      </code></pre>
      </article>

      <article>
        <h2>04- Working with Files</h2>
        <p>
          Python provides a variety of functions for working with files. You can
          use these functions to read, write, and manipulate files on your file
          system.
        </p>
        <p>
          To open a file in Python, you can use the built-in
          <code>open()</code> function. This function takes two arguments: the
          path to the file you want to open, and the mode in which you want to
          open the file (read mode, write mode, etc.).
        </p>
        <pre class="language-python">
<code>
# Open a file in read mode
file = open('file_path', 'r')
  </code></pre>
        <p>
          Once you have opened a file, you can read its contents using the
          <code>read()</code> method:
        </p>
        <pre class="language-python">
<code>
# Read the contents of a file
file = open('file_path', 'r')
contents = file.read()
print(contents)
  </code></pre>
        <p>
          You can also write to a file using the <code>write()</code> method:
        </p>
        <pre class="language-python">
<code>
# Write to a file
file = open('file_path', 'w')
file.write('Hello, world!')
file.close()
  </code></pre>
        <p>
          Note that when you open a file in write mode, the contents of the file
          will be overwritten. If you want to append to an existing file instead
          of overwriting it, you can open the file in append mode:
        </p>
        <pre class="language-python">
<code>
# Append to a file
file = open('file_path', 'a')
file.write('Hello, world!')
file.close()
  </code></pre>
        <p>
          Finally, when you are done working with a file, you should close it
          using the <code>close()</code> method:
        </p>
        <pre class="language-python">
<code>
# Close a file
file = open('file_path', 'r')
contents = file.read()
file.close()
  </code></pre>
      </article>
      <article>
        <h2>05- Working with Zip Files</h2>
        <p>
          Python provides a built-in <code>zipfile</code> module that allows you
          to create, read, and extract files from zip archives. This can be
          useful if you need to compress multiple files into a single archive,
          or if you need to extract files from an existing archive.
        </p>
        <p>
          Here's an example of how to create a new zip archive and add files to
          it using the <code>zipfile.ZipFile()</code> function:
        </p>
        <pre class="language-python">
<code>
      import zipfile
      # Create a new zip archive and add files to it
      with zipfile.ZipFile('archive.zip', 'w') as zip:
      zip.write('file1.txt')
      zip.write('file2.txt')
      </code></pre>

        <p>
          You can also extract files from an existing zip archive using the
          <code>zipfile.ZipFile()</code> function and the
          <code>extractall()</code> method:
        </p>
        <pre class="language-python">
<code>
      import zipfile
      # Extract files from a zip archive
      with zipfile.ZipFile('archive.zip', 'r') as zip:
      zip.extractall('extracted_files')
      </code></pre>

        <p>
          This will extract all the files in the zip archive to the directory
          specified by the <code>extractall()</code> method.
        </p>
        <p>
          You can also read the contents of a zip archive using the
          <code>zipfile.ZipFile()</code> function and the
          <code>namelist()</code> method:
        </p>
        <pre class="language-python">
<code>
      import zipfile
      # Read the contents of a zip archive
      with zipfile.ZipFile('archive.zip', 'r') as zip:
      contents = zip.namelist()
      print(contents)
      </code></pre>

        <p>
          This will print a list of the names of all the files in the zip
          archive.
        </p>
      </article>
      <article>
        <h2>06- Working with CSV Files</h2>
        <p>
          Comma Separated Values (CSV) is a file format used to store tabular
          data, such as a spreadsheet or a database. Python provides a built-in
          <code>csv</code> module that allows you to easily read and write CSV
          files.
        </p>
        <p>
          Here's an example of how to read a CSV file using the
          <code>csv</code> module:
        </p>
        <pre class="language-python">
<code>
      import csv
      # Read a CSV file
      with open('data.csv', newline='') as csvfile:
      reader = csv.reader(csvfile, delimiter=',', quotechar='"')
      for row in reader:
      print(', '.join(row))
      </code></pre>

        <p>
          This will print each row of the CSV file to the console. The
          <code>delimiter</code> argument specifies the character used to
          separate the values in the CSV file (which is usually a comma), and
          the <code>quotechar</code> argument specifies the character used to
          enclose values that contain the delimiter character.
        </p>
        <p>
          Here's an example of how to write a CSV file using the
          <code>csv</code> module:
        </p>
        <pre class="language-python">
<code>
      import csv
      # Write a CSV file
      with open('data.csv', 'w', newline='') as csvfile:
      writer = csv.writer(csvfile, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
      writer.writerow(['Name', 'Age', 'City'])
      writer.writerow(['John', '25', 'New York'])
      writer.writerow(['Jane', '30', 'San Francisco'])
      </code></pre>

        <p>
          This will create a new CSV file with the specified rows and columns.
        </p>
      </article>
      <article>
        <h2>07- Working with JSON Files</h2>
        <p>
          JSON (JavaScript Object Notation) is a lightweight data interchange
          format that is easy for humans to read and write and easy for machines
          to parse and generate. Python provides a built-in
          <code>json</code> module that allows you to easily read and write JSON
          files.
        </p>
        <p>
          Here's an example of how to read a JSON file using the
          <code>json</code> module:
        </p>
        <pre class="language-python">
<code>
      import json
      # Read a JSON file
      with open('data.json') as jsonfile:
      data = json.load(jsonfile)
      print(data)
      </code></pre>

        <p>
          This will print the contents of the JSON file to the console as a
          Python dictionary.
        </p>
        <p>
          Here's an example of how to write a Python dictionary to a JSON file
          using the <code>json</code> module:
        </p>
        <pre class="language-python">
<code>
      import json
      # Write a dictionary to a JSON file
      data = {
      'Name': 'John',
      'Age': 25,
      'City': 'New York'
      }
      
      with open('data.json', 'w') as jsonfile:
      json.dump(data, jsonfile)
      </code></pre>

        <p>
          This will create a new JSON file with the specified dictionary as its
          contents.
        </p>
      </article>
      <article>
        <h2>08- Working with a SQLite Database</h2>
        <p>
          SQLite is a self-contained, serverless, zero-configuration,
          transactional SQL database engine. Python provides a built-in
          <code>sqlite3</code> module that allows you to easily connect to an
          SQLite database, execute SQL queries, and manipulate the data in the
          database.
        </p>
        <p>
          Here's an example of how to connect to an SQLite database and execute
          an SQL query using the <code>sqlite3</code> module:
        </p>
        <pre class="language-python">
<code>
      import sqlite3
      # Connect to an SQLite database
      conn = sqlite3.connect('example.db')
      
      # Create a cursor object to execute SQL queries
      cursor = conn.cursor()
      
      # Execute an SQL query
      cursor.execute("SELECT * FROM users")
      
      # Fetch the results
      results = cursor.fetchall()
      
      # Print the results
      for row in results:
      print(row)
      
      # Close the cursor and the connection
      cursor.close()
      conn.close()
      </code></pre>

        <p>
          This will connect to the SQLite database, execute the specified SQL
          query, and print the results to the console.
        </p>
        <p>
          Here's an example of how to insert data into an SQLite database using
          the <code>sqlite3</code> module:
        </p>
        <pre class="language-python">
<code>
      import sqlite3
      # Connect to an SQLite database
      conn = sqlite3.connect('example.db')
      
      # Create a cursor object to execute SQL queries
      cursor = conn.cursor()
      
      # Insert data into a table
      cursor.execute("INSERT INTO users (name, age, city) VALUES (?, ?, ?)", ('John', 25, 'New York'))
      
      # Commit the changes
      conn.commit()
      
      # Close the cursor and the connection
      cursor.close()
      conn.close()
      </code></pre>

        <p>
          This will insert a new row into the specified table in the SQLite
          database.
        </p>
      </article>
      <article>
        <h2>09- Working with Timestamps</h2>
        <p>
          A timestamp is a sequence of characters or encoded information
          identifying when a certain event occurred, usually giving date and
          time of day, sometimes accurate to a small fraction of a second.
          Python provides a built-in <code>datetime</code> module that allows
          you to easily work with timestamps and dates.
        </p>
        <p>
          Here's an example of how to get the current date and time using the
          <code>datetime</code> module:
        </p>
        <pre class="language-python">
<code>
      from datetime import datetime
      # Get the current date and time
      now = datetime.now()
      
      Print the current date and time
      print("Current Date and Time:", now)
      </code></pre>

        <p> This will print the current date and time to the console. </p>
        <p>
          Here's an example of how to convert a timestamp to a human-readable
          date and time using the <code>datetime</code> module:
        </p>
        <pre class="language-python">
<code>
      from datetime import datetime
      # Convert a timestamp to a human-readable date and time
      timestamp = 1620485979
      date_time = datetime.fromtimestamp(timestamp)
      
      Print the converted date and time
      print("Converted Date and Time:", date_time)
      </code></pre>

        <p>
          This will convert the specified timestamp to a human-readable date and
          time and print it to the console.
        </p>
        <p>
          Here's an example of how to format a date and time string using the
          <code>datetime</code> module:
        </p>
        <pre class="language-python">
<code>
      from datetime import datetime
      # Format a date and time string
      now = datetime.now()
      date_time_string = now.strftime("%Y-%m-%d %H:%M:%S")
      
      # Print the formatted date and time string
      print("Formatted Date and Time:", date_time_string)
      </code></pre>

        <p>
          This will format the current date and time as a string in the
          specified format and print it to the console.
        </p>
      </article>
      <article>
        <h2>10- Working with DateTimes</h2>
        <p>
          The <code>datetime</code> module also provides a class called
          <code>date</code>, which allows you to work with dates independently
          of time. Here's an example of how to create a <code>date</code> object
          representing a specific date:
        </p>
        <pre class="language-python">
<code>
      from datetime import date
      Create a date object representing January 1st, 2022
      d = date(2022, 1, 1)
      
      Print the date object
      print("Date Object:", d)
      </code></pre>

        <p>
          This will create a <code>date</code> object representing January 1st,
          2022 and print it to the console.
        </p>
        <p>
          You can also get the current date using the
          <code>date.today()</code> method:
        </p>
        <pre class="language-python">
<code>
      from datetime import date
      Get the current date
      today = date.today()
      
      Print the current date
      print("Today's Date:", today)
      </code></pre>

        <p> This will get the current date and print it to the console. </p>
        <p>
          You can also perform arithmetic operations on
          <code>date</code> objects. For example, you can calculate the number
          of days between two dates:
        </p>
        <pre class="language-python">
<code>
      from datetime import date
      # Create two date objects
      d1 = date(2022, 1, 1)
      d2 = date(2022, 12, 31)
      
      # Calculate the number of days between the two dates
      delta = d2 - d1
      
      Print the number of days
      print("Number of Days:", delta.days)
      </code></pre>

        <p>
          This will create two <code>date</code> objects representing January
          1st, 2022 and December 31st, 2022, calculate the number of days
          between them, and print it to the console.
        </p>
      </article>
      <article>
        <h2>11- Working with Time Deltas</h2>
        <p>
          A <code>timedelta</code> is a duration expressing the difference
          between two dates or times. You can create a <code>timedelta</code> by
          subtracting two <code>datetime</code> objects, and you can perform
          arithmetic operations on <code>timedelta</code> objects. Here's an
          example:
        </p>
        <pre class="language-python">
<code>
      from datetime import datetime, timedelta
      # Get the current datetime
      now = datetime.now()
      
      # Create a timedelta of 10 days
      delta = timedelta(days=10)
      
      # Calculate the datetime 10 days from now
      future = now + delta
      
      # Print the future datetime
      print("Future Date:", future)
      </code></pre>

        <p>
          This will get the current <code>datetime</code>, create a
          <code>timedelta</code> object representing 10 days, calculate the
          datetime 10 days from now, and print it to the console.
        </p>
        <p>
          You can also perform arithmetic operations on
          <code>timedelta</code> objects. For example, you can calculate the
          difference between two datetimes:
        </p>
        <pre class="language-python">
<code>
      from datetime import datetime, timedelta
      # Create two datetime objects
      d1 = datetime(2022, 1, 1)
      d2 = datetime(2022, 12, 31)
      
      # Calculate the timedelta between the two datetimes
      delta = d2 - d1
      
      Print the timedelta
      print("Time Delta:", delta)
      </code></pre>

        <p>
          This will create two <code>datetime</code> objects representing
          January 1st, 2022 and December 31st, 2022, calculate the
          <code>timedelta</code> between them, and print it to the console.
        </p>
      </article>
      <article>
        <h2>12- Generating Random Values</h2>
        <p>
          Python has a built-in <code>random</code> module that can be used to
          generate random values. Here are a few examples:
        </p>
        <ol>
          <li>
            Generating a random integer between two values:
            <pre class="language-python">
<code>
      import random
      # Generate a random integer between 1 and 10 (inclusive)
      x = random.randint(1, 10)
      
      # Print the random integer
      print("Random Integer:", x)
      </code></pre>
          </li>
          <li>
            Generating a random floating-point number between two values:
            <pre class="language-python">
<code>
      import random
      
      # Generate a random floating-point number between 0 and 1
      x = random.random()
      
      # Print the random number
      print("Random Float:", x)
      </code></pre>
          </li>
          <li>
            Shuffling a list:
            <pre class="language-python">
<code>
      import random
      
      # Create a list of numbers
      numbers = [1, 2, 3, 4, 5]
      
      # Shuffle the list
      random.shuffle(numbers)
      
      # Print the shuffled list
      print("Shuffled List:", numbers)
      </code></pre>
          </li>
        </ol>
        <p>
          There are many other functions in the <code>random</code> module that
          can be used to generate random values, such as <code>randrange</code>,
          <code>uniform</code>, <code>gauss</code>, and <code>choices</code>.
          Refer to the official Python documentation for more information.
        </p> </article
      ><article>
        <h2>13- Opening the Browser</h2>
        <p>
          Sometimes you may need to open a web page in the user's default
          browser from within a Python script. This can be done using the
          built-in <code>webbrowser</code> module. Here's an example:
        </p>
        <pre class="language-python">
<code>
      import webbrowser
      # Open the Python homepage in the user's default browser
      webbrowser.open('https://www.python.org/')
      </code></pre>

        <p>
          The <code>open</code> function takes a single argument, which is the
          URL of the web page to open. This function will launch the user's
          default browser and open the specified page. If the browser is already
          open, it will create a new tab and load the page in that tab.
        </p>
        <p>
          There are other functions available in the
          <code>webbrowser</code> module that can be used to open web pages in
          different ways. For example, the <code>open_new</code> function will
          open the specified URL in a new browser window, while the
          <code>open_new_tab</code> function will open the URL in a new browser
          tab. Refer to the official Python documentation for more information.
        </p>
      </article>
      <article>
        <h2>14- Sending Emails</h2>
        <p>
          Python provides a built-in <code>smtplib</code> module for sending
          emails. Here's an example of how to use it:
        </p>
        <pre class="language-python">
<code>
      import smtplib
      # Set up the email message
      subject = 'Test Email'
      body = 'This is a test email sent from Python!'
      message = f'Subject: {subject}\n\n{body}'
      
      # Connect to the SMTP server
      with smtplib.SMTP('smtp.gmail.com', 587) as smtp:
      
      # Start the TLS encryption
      smtp.starttls()
      
      # Log in to the SMTP server
      smtp.login('your_email@gmail.com', 'your_password')
      
      # Send the email
      smtp.sendmail('your_email@gmail.com', 'recipient_email@example.com', message)
      </code></pre>

        <p>
          In this example, we first set up the email message by defining the
          subject and body of the email. We then create a formatted string that
          includes the subject and body, separated by two newlines.
        </p>
        <p>
          Next, we connect to the SMTP server using the <code>SMTP</code> class.
          In this case, we're using the Gmail SMTP server and connecting on port
          587. We then start the TLS encryption and log in to the SMTP server
          using our email address and password.
        </p>
        <p>
          Finally, we use the <code>sendmail</code> method to send the email.
          This method takes three arguments: the sender's email address, the
          recipient's email address, and the message itself.
        </p>
        <p>
          Note that in order to use this code, you'll need to replace
          <code>your_email@gmail.com</code> and <code>your_password</code> with
          your own email address and password, respectively. Additionally,
          you'll need to change <code>recipient_email@example.com</code> to the
          email address of the person you want to send the email to.
        </p>
      </article>
      <article>
        <h2>15- Templates</h2>
        <p>
          Python's built-in <code>string.Template</code> class provides a simple
          way to substitute values into a template string. Here's an example:
        </p>
        <pre class="language-python">
<code>
      # from string import Template
      Define the template string
      template_str = 'Hello, $name! You have $unread_messages unread messages.'
      
      # Create a Template object
      template = Template(template_str)
      
      # Substitute values into the template
      result = template.substitute(name='Alice', unread_messages=3)
      
      # Print the result
      print(result)
      </code></pre>

        <p>
          In this example, we define a template string that includes two
          placeholders, <code>$name</code> and <code>$unread_messages</code>. We
          then create a <code>Template</code> object from the template string.
        </p>
        <p>
          To substitute values into the template, we call the
          <code>substitute</code> method on the <code>Template</code> object and
          pass in keyword arguments that correspond to the placeholders in the
          template string. The <code>substitute</code> method returns a new
          string with the placeholders replaced by the provided values.
        </p>
        <p>
          In this example, the <code>result</code> variable will contain the
          string <code>Hello, Alice! You have 3 unread messages.</code>.
        </p>
        <p>
          Note that you can also use <code>$</code> as a delimiter for the
          placeholders, instead of <code>${}</code>. In that case, you would
          define the template string as
          <code
            >'Hello, $name! You have $unread_messages unread messages.'</code
          >
          and call the <code>substitute</code> method without the
          <code>{}</code> around the keyword arguments.
        </p>
      </article>
      <article>
        <h2>16- Command-line Arguments</h2>
        <p>
          Python provides a module called <code>argparse</code> that makes it
          easy to parse command-line arguments in your Python scripts. Here's a
          simple example:
        </p>
        <pre class="language-python">
<code>
      import argparse
      # Create a parser object
      parser = argparse.ArgumentParser()
      
      # Add a positional argument
      parser.add_argument('name', help='the name to greet')
      
      # Add an optional argument
      parser.add_argument('--greeting', default='Hello', help='the greeting to use')
      
      # Parse the arguments
      args = parser.parse_args()
      
      # Generate the greeting
      greeting = f"{args.greeting}, {args.name}!"
      
      # Print the greeting
      print(greeting)
      </code></pre>

        <p>
          In this example, we first import the <code>argparse</code> module and
          create a <code>ArgumentParser</code> object. We then add two arguments
          to the parser: a required positional argument named <code>name</code>,
          and an optional argument named <code>greeting</code> with a default
          value of <code>'Hello'</code>.
        </p>
        <p>
          We then call <code>parser.parse_args()</code> to parse the
          command-line arguments and store them in an <code>args</code> object.
          We can access the values of the arguments by using dot notation on the
          <code>args</code> object.
        </p>
        <p>
          In this example, we generate a greeting string using the
          <code>args</code> object, and then print it to the console.
        </p>
        <p>
          To run this script, you would invoke it from the command line like
          this:
        </p>
        <pre><code>python greeting.py Alice --greeting "Hi"</code></pre>
        <p>
          This would generate the greeting <code>Hi, Alice!</code> instead of
          the default <code>Hello, Alice!</code>.
        </p>
      </article>
      <article>
        <h2>17- Running External Programs</h2>
        <p>
          Python provides a way to run external programs using the
          <code>subprocess</code> module. Here's a simple example:
        </p>
        <pre class="language-python">
<code>
      import subprocess
      # Run the 'ls' command and capture the output
      result = subprocess.run(['ls', '-l'], stdout=subprocess.PIPE)
      
      # Print the output
      print(result.stdout.decode('utf-8'))
      </code></pre>

        <p>
          In this example, we first import the <code>subprocess</code> module.
          We then use the <code>subprocess.run()</code> method to run the
          <code>ls -l</code> command (which lists the files in the current
          directory in long format) and capture the output in a variable called
          <code>result</code>.
        </p>
        <p>
          We can then print the output to the console by decoding the
          <code>result.stdout</code> bytes object using the
          <code>utf-8</code> encoding.
        </p>
        <p>
          The <code>subprocess.run()</code> method also provides many options
          for customizing how the command is run, such as setting the working
          directory, redirecting input/output streams, and more. Check out the
          Python documentation for more information.
        </p>
      </article>
      <h2 class="a-main-topic">10 Python Package Index</h2>
      <article>
        <h2>01 - PyPI</h2>
        <p
          >PyPI (Python Package Index) is a repository of software for the
          Python programming language. It allows you to search, download, and
          install packages written by other Python developers.</p
        >
        <p
          >Using PyPI, you can easily download and install any Python package
          using the pip package manager. Pip is a package manager for Python
          packages, which is used to install, upgrade, and manage Python
          packages.</p
        >
        <p
          >To install a package using pip, you need to open the terminal or
          command prompt and type:</p
        >
        <pre class="language-python">
<code>pip install package_name</code></pre>
        <p
          >For example, to install the popular NumPy package, you would type:</p
        >
        <pre class="language-python">
<code>pip install numpy</code></pre>
        <p
          >You can also install a specific version of a package by specifying
          the version number:</p
        >
        <pre
          class="language-python"
        ><code>pip install package_name==version_number</code></pre>
        <p
          >If you want to uninstall a package, you can use the following
          command:</p
        >
        <pre
          class="language-python"
        ><code>pip uninstall package_name</code></pre>
        <p
          >To see a list of all the packages installed on your system, use the
          following command:</p
        >
        <pre class="language-python">
<code>pip list</code></pre>
        <p
          >PyPI contains a vast collection of Python packages that you can use
          to add functionality to your Python applications. Whether you need to
          work with databases, process data, create web applications, or perform
          scientific computing, there's a good chance that a package already
          exists on PyPI that can help you achieve your goals.</p
        >
        <p
          >Overall, PyPI is an essential tool for any Python developer, and
          understanding how to use it will help you to be more productive and
          efficient.</p
        >
      </article>
      <article>
        <h2>02 - Pip</h2>
        <p
          >Pip is a package manager for Python packages that allows you to
          easily install, upgrade, and manage Python packages and their
          dependencies. Pip is included by default in Python 3.4 and later
          versions, but if you're using an older version of Python, you may need
          to install it manually.</p
        >
        <p
          >You can check if you have pip installed on your system by opening the
          terminal or command prompt and typing:</p
        >
        <pre class="language-python">
<code>pip --version</code></pre>
        <p
          >If you don't have pip installed, you can download and install it
          using the following steps:</p
        >
        <ol>
          <li
            >Download get-pip.py from
            <a href="https://bootstrap.pypa.io/get-pip.py"
              >https://bootstrap.pypa.io/get-pip.py</a
            ></li
          >
          <li
            >Open a terminal or command prompt and navigate to the directory
            where you downloaded get-pip.py</li
          >
          <li>Type the following command:</li>
          <pre class="language-python">
<code>python get-pip.py</code></pre>
          <li
            >After the installation is complete, you can use pip to install
            Python packages.</li
          >
        </ol>
        <p
          >To install a package using pip, you need to open the terminal or
          command prompt and type:</p
        >
        <pre class="language-python">
<code>pip install package_name</code></pre>
        <p
          >For example, to install the popular NumPy package, you would type:</p
        >
        <pre class="language-python">
<code>pip install numpy</code></pre>
        <p
          >You can also install a specific version of a package by specifying
          the version number:</p
        >
        <pre
          class="language-python"
        ><code>pip install package_name==version_number</code></pre>
        <p
          >If you want to uninstall a package, you can use the following
          command:</p
        >
        <pre
          class="language-python"
        ><code>pip uninstall package_name</code></pre>
        <p
          >To see a list of all the packages installed on your system, use the
          following command:</p
        >
        <pre class="language-python">
<code>pip list</code></pre>
        <p
          >Pip also allows you to install packages from a requirements file. A
          requirements file is a text file that lists all the Python packages
          that your project depends on. You can create a requirements file using
          any text editor, and it should have one package per line with an
          optional version number. To install packages from a requirements file,
          you need to open the terminal or command prompt and type:</p
        >
        <pre
          class="language-python"
        ><code>pip install -r requirements.txt</code></pre>
        <p
          >Overall, pip is a powerful tool that makes it easy to manage Python
          packages and dependencies, and understanding how to use it will help
          you to be more productive and efficient.</p
        >
      </article>
      <article>
        <h2>03 - Virtual Environments</h2>
        <p
          >Virtual environments are a powerful tool that allows you to create
          isolated Python environments for your projects. Each virtual
          environment has its own Python interpreter, package set, and
          environment variables, which means that you can have multiple versions
          of Python and different sets of packages on the same system without
          them conflicting with each other.</p
        >
        <p
          >The main benefit of using virtual environments is that it makes it
          easy to manage the dependencies of your projects. You can install the
          packages you need for a specific project without affecting the
          packages installed in other virtual environments or the system's
          global Python environment. This makes it easier to develop and test
          your projects in different environments and ensures that your projects
          work correctly regardless of the environment they are running in.</p
        >
        <p
          >To create a new virtual environment, you can use the venv module,
          which is included with Python 3.3 and later versions. To create a new
          virtual environment, open the terminal or command prompt and navigate
          to the directory where you want to create the environment, then
          type:</p
        >
        <pre class="language-python">
<code>python -m venv env_name</code></pre>
        <p
          >This will create a new virtual environment with the name
          <code>env_name</code> in the current directory. To activate the
          virtual environment, you need to type:</p
        >
        <pre
          class="language-python"
        ><code>source env_name/bin/activate</code></pre>
        <p>On Windows, you should type:</p>
        <pre
          class="language-python"
        ><code>env_name\Scripts\activate</code></pre>
        <p
          >Once the virtual environment is activated, you can install packages
          using pip, just like you would in a normal Python environment. For
          example, to install the popular NumPy package, you would type:</p
        >
        <pre class="language-python">
<code>pip install numpy</code></pre>
        <p
          >When you're done working in the virtual environment, you can
          deactivate it by typing:</p
        >
        <pre class="language-python">
<code>deactivate</code></pre>
        <p
          >Overall, virtual environments are an essential tool for Python
          developers, and using them will help you to manage your projects'
          dependencies and ensure that your code works correctly in different
          environments.</p
        >
      </article>
      <article>
        <h2>04- Pipenv</h2>
        <p
          >Pipenv is a higher-level tool built on top of pip, which simplifies
          the process of managing project dependencies and virtual environments.
          It provides a single command-line tool for managing dependencies,
          virtual environments, and project settings, which makes it easier to
          use than pip and venv separately.</p
        >
        <p
          >To use Pipenv, you need to install it first using pip. You can do
          this by typing:</p
        >
        <pre class="language-python">
<code>pip install pipenv</code></pre>
        <p
          >Once Pipenv is installed, you can use it to create a new virtual
          environment for your project, along with a <code>Pipfile</code> that
          lists the dependencies for your project. To create a new virtual
          environment, navigate to the project directory and type:</p
        >
        <pre class="language-python">
<code>pipenv --python 3.9</code></pre>
        <p
          >This will create a new virtual environment with Python 3.9 and
          generate a <code>Pipfile</code> in the project directory. You can then
          add the dependencies you need for your project to the
          <code>Pipfile</code>. For example, to add the popular Flask package,
          you would type:</p
        >
        <pre class="language-python">
<code>pipenv install flask</code></pre>
        <p
          >This will install Flask and its dependencies in the virtual
          environment and update the <code>Pipfile</code> accordingly. Pipenv
          also creates a <code>Pipfile.lock</code> file, which specifies the
          exact versions of the packages installed, ensuring that the same
          dependencies are installed on any system.</p
        >
        <p
          >Once you've added your dependencies, you can run your project in the
          virtual environment using Pipenv. To start a new shell in the virtual
          environment, type:</p
        >
        <pre class="language-python">
<code>pipenv shell</code></pre>
        <p
          >This will start a new shell with the virtual environment activated,
          so you can run your Python code with the dependencies you've
          installed.</p
        >
        <p
          >Overall, Pipenv is a powerful tool that simplifies the process of
          managing dependencies and virtual environments for your Python
          projects. If you're working on a complex project with many
          dependencies, it can save you a lot of time and hassle.</p
        >
      </article>
      <article>
        <h2>05- Virtual Environments in VSCode</h2>
        <p
          >Virtual environments are an essential tool for managing dependencies
          and isolating projects in Python. In this note, we will cover how to
          set up and use virtual environments in VSCode.</p
        >
        <p
          >The first step is to install the Python extension for VSCode. You can
          do this by going to the Extensions tab on the left-hand side of VSCode
          and searching for "Python". Once you've installed the extension, you
          should see a Python icon in the left-hand menu.</p
        >
        <p
          >Next, open the Command Palette in VSCode by pressing
          <span>Ctrl + Shift + P</span> (Windows) or
          <span>Cmd + Shift + P</span> (Mac). Search for "Python: Select
          Interpreter" and select the option that matches the virtual
          environment you want to use for your project. If you don't see your
          virtual environment in the list, you may need to create one first.</p
        >
        <p
          >To create a new virtual environment, you can use the built-in
          <code>venv</code> module in Python. Open a terminal in VSCode by
          pressing <span>Ctrl + `</span> (Windows) or
          <span>Cmd + `</span> (Mac), and navigate to the directory where you
          want to create the virtual environment. Then type:</p
        >
        <pre class="language-python">
<code>python -m venv myenv</code></pre>
        <p
          >This will create a new virtual environment named
          <code>myenv</code> in the current directory. You can then activate the
          virtual environment by typing:</p
        >
        <pre
          class="language-python"
        ><code>source myenv/bin/activate</code></pre>
        <p
          >Once the virtual environment is activated, you can install any
          dependencies you need for your project using pip, just like you would
          in a regular Python environment.</p
        >
        <p
          >Back in VSCode, you should now see the name of your virtual
          environment in the bottom left corner of the screen. This indicates
          that you're using the correct Python interpreter for your project. You
          can also see a list of installed packages by opening the "Python: Show
          Python Environment" command in the Command Palette.</p
        >
        <p
          >In summary, virtual environments are a powerful tool for managing
          dependencies and isolating projects in Python, and VSCode makes it
          easy to use them in your development workflow.</p
        >
      </article>
      <article>
        <h2>06- Pipfile</h2>
        <p
          >Pipenv is a popular tool for managing dependencies and virtual
          environments in Python. It uses a <code>Pipfile</code> to define the
          dependencies for a project and creates a virtual environment based on
          those dependencies. In this note, we will cover how to use Pipenv and
          the Pipfile.</p
        >
        <p
          >To get started, you need to install Pipenv. You can do this using
          pip:</p
        >
        <pre class="language-python">
<code>pip install pipenv</code></pre>
        <p
          >Once Pipenv is installed, you can create a new project by navigating
          to the project directory in your terminal and running:</p
        >
        <pre class="language-python">
<code>pipenv --python 3.9</code></pre>
        <p
          >This will create a new virtual environment based on Python 3.9 and
          create a <code>Pipfile</code> in your project directory. You can then
          add dependencies to your <code>Pipfile</code> using the following
          command:</p
        >
        <pre
          class="language-python"
        ><code>pipenv install &lt;package-name&gt;</code></pre>
        <p
          >You can also specify the version of the package you want to
          install:</p
        >
        <pre
          class="language-python"
        ><code>pipenv install &lt;package-name&gt;==&lt;version&gt;</code></pre>
        <p
          >To install all dependencies listed in the <code>Pipfile</code>,
          simply run:</p
        >
        <pre class="language-python">
<code>pipenv install</code></pre>
        <p>You can also create a <code>Pipfile.lock</code> file by running:</p>
        <pre class="language-python">
<code>pipenv lock</code></pre>
        <p
          >This file will lock the dependencies to specific versions, ensuring
          that your project dependencies are consistent across different
          environments.</p
        >
        <p
          >To activate the virtual environment created by Pipenv, simply run:</p
        >
        <pre class="language-python">
<code>pipenv shell</code></pre>
        <p
          >This will activate the virtual environment and give you access to the
          installed dependencies. You can then run your Python code as usual.</p
        >
        <p
          >In summary, Pipenv and the <code>Pipfile</code> are powerful tools
          for managing dependencies and virtual environments in Python. They
          make it easy to create reproducible environments for your projects and
          ensure that dependencies are consistent across different
          environments.</p
        >
      </article>
      <article>
        <h2>07- Managing Dependencies</h2>
        <p
          >When developing a Python project, managing dependencies is crucial to
          ensure that your code can be run consistently across different
          environments. In this note, we will cover some best practices for
          managing dependencies in your Python projects.</p
        >
        <h3>Use a Virtual Environment</h3>
        <p
          >Using a virtual environment is essential for managing dependencies in
          Python. A virtual environment is an isolated environment that allows
          you to install packages without affecting the global Python
          environment. There are several tools available for creating virtual
          environments, including <code>venv</code>, <code>virtualenv</code>,
          and <code>pipenv</code>.</p
        >
        <h3>Use a Requirements File</h3>
        <p
          >A requirements file is a simple text file that lists all the packages
          required for your project. You can create a requirements file by
          running:</p
        >
        <pre
          class="language-python"
        ><code>pip freeze &gt; requirements.txt</code></pre>
        <p
          >This will create a file named <code>requirements.txt</code> that
          contains a list of all the packages installed in your virtual
          environment.</p
        >
        <p
          >You can then use this file to install the required packages on
          another machine or in a different environment by running:</p
        >
        <pre
          class="language-python"
        ><code>pip install -r requirements.txt</code></pre>
        <h3>Pin Your Dependencies</h3>
        <p
          >When listing dependencies in your requirements file, it's important
          to pin the version of each package to ensure that the same version is
          installed across all environments. You can pin the version of a
          package by specifying it in the requirements file like this:</p
        >
        <pre class="language-python">
<code>package-name==1.2.3</code></pre>
        <h3>Update Dependencies Regularly</h3>
        <p
          >It's important to update your dependencies regularly to ensure that
          your project is using the latest version of each package and to
          address any security vulnerabilities or bugs. You can update your
          dependencies by running:</p
        >
        <pre
          class="language-python"
        ><code>pip install --upgrade package-name</code></pre>
        <p
          >You can also update all packages in your virtual environment by
          running:</p
        >
        <pre
          class="language-python"
        ><code>pip freeze | sed -e 's/==/~=/g' | xargs pip install -U</code></pre>
        <p>This will update all packages to their latest compatible version.</p>
        <h3>Conclusion</h3>
        <p
          >Managing dependencies is essential for developing and maintaining
          Python projects. By using virtual environments, requirements files,
          pinning dependencies, and regularly updating your dependencies, you
          can ensure that your code runs consistently across different
          environments and stays up-to-date with the latest packages and
          security fixes.</p
        >
      </article>
      <article>
        <h2>08- Publishing Packages</h2>
        <p
          >If you've created a Python package that you want to share with
          others, you can publish it to the Python Package Index (PyPI) so that
          others can easily install and use it in their projects. In this note,
          we'll cover the steps for publishing a package to PyPI.</p
        >
        <h3>Create a Source Distribution</h3>
        <p
          >The first step in publishing a package to PyPI is to create a source
          distribution. This is a compressed archive of your package's source
          code that includes a <code>setup.py</code> file, which contains
          information about your package, such as its name, version, and
          dependencies. To create a source distribution, run the following
          command in your package's root directory:</p
        >
        <pre class="language-python">
<code>python setup.py sdist</code></pre>
        <p
          >This will create a <code>.tar.gz</code> file in the
          <code>dist</code> directory, which you can use to distribute your
          package.</p
        >
        <h3>Create a Wheel Distribution</h3>
        <p
          >In addition to a source distribution, you can also create a wheel
          distribution, which is a pre-built binary package that can be
          installed directly on a user's machine. To create a wheel
          distribution, run the following command:</p
        >
        <pre
          class="language-python"
        ><code>python setup.py bdist_wheel</code></pre>
        <p
          >This will create a <code>.whl</code> file in the
          <code>dist</code> directory, which you can use to distribute your
          package.</p
        >
        <h3>Create an Account on PyPI</h3>
        <p
          >Before you can publish your package to PyPI, you need to create an
          account on the PyPI website. You can create an account by visiting
          <a href="https://pypi.org/account/register/"
            >https://pypi.org/account/register/</a
          >
          and following the instructions.</p
        >
        <h3>Upload Your Package</h3>
        <p
          >Once you've created an account on PyPI, you can upload your package
          using the <code>twine</code> tool, which can be installed by
          running:</p
        >
        <pre class="language-python">
<code>pip install twine</code></pre>
        <p
          >To upload your package, first, navigate to the
          <code>dist</code> directory and run:</p
        >
        <pre class="language-python">
<code>twine upload dist/*</code></pre>
        <p
          >This will prompt you for your PyPI username and password and will
          upload your package to PyPI.</p
        >
        <h3>Conclusion</h3>
        <p
          >Publishing a package to PyPI is a straightforward process that
          involves creating a source and/or wheel distribution, creating an
          account on PyPI, and uploading your package using the
          <code>twine</code> tool. Once your package is published on PyPI,
          others can easily install and use it in their Python projects.</p
        >
      </article>
      <article>
        <h2>09- Docstrings</h2>
        <p
          >Docstrings are a way to document Python functions, modules, and
          classes. A docstring is a string literal that appears as the first
          statement in a module, function, or class definition. Docstrings are
          used to provide documentation for your code, and they are also used by
          various tools, such as IDEs and documentation generators, to
          automatically generate documentation.</p
        >
        <h3>Function Docstrings</h3>
        <p
          >When documenting a function using a docstring, the docstring should
          describe what the function does, what arguments it takes, and what it
          returns. Here's an example:</p
        >
        <pre class="language-python">
<code>def greet(name):
          """Greet the user by name.
            Args:
            name (str): The name of the user to greet.

            Returns:
                str: The greeting message.
          """
          return f"Hello, {name}!"</code></pre>
        <p
          >The docstring for this function provides a brief description of what
          the function does, as well as information about the argument it takes
          and the value it returns. The <code>Args:</code> and
          <code>Returns:</code> sections are used to document the function's
          arguments and return value, respectively.</p
        >
        <h3>Module Docstrings</h3>
        <p
          >When documenting a module using a docstring, the docstring should
          provide an overview of the module and its contents. Here's an
          example:</p
        >
        <pre
          class="language-python"
        ><code>"""This module contains functions for performing mathematical operations."""</code></pre>
        <p
          >The docstring for this module provides a brief description of what
          the module contains.</p
        >
        <h3>Class Docstrings</h3>
        <p
          >When documenting a class using a docstring, the docstring should
          describe what the class does and how it is intended to be used. Here's
          an example:</p
        >
        <pre class="language-python">
<code>class Dog:
    """A class representing a dog.
      Attributes:
      name (str): The name of the dog.
      breed (str): The breed of the dog.
    """
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed</code></pre>
        <p
          >The docstring for this class provides a brief description of what the
          class represents, as well as information about its attributes.</p
        >
        <h3>Conclusion</h3>
        <p
          >Docstrings are an important part of writing Python code, as they
          provide documentation for your code and make it easier for others to
          understand and use. By following the conventions for writing
          docstrings, you can ensure that your code is well-documented and easy
          to maintain.</p
        >
      </article>
      <article>
        <h2>10- Pydoc</h2>
        <p
          >Pydoc is a tool that generates documentation from Python modules,
          classes, and functions. Pydoc can be used to generate HTML
          documentation, plain text documentation, or documentation in other
          formats. Pydoc is particularly useful for generating documentation for
          your own code, as well as for exploring and understanding third-party
          libraries.</p
        >
        <h3>Using Pydoc</h3>
        <p
          >To use Pydoc, you can run it from the command line by typing
          <span class="language-python"> pydoc</span>, followed by the name of
          the module, class, or function you want to generate documentation for.
          For example, to generate documentation for the
          <span class="language-python"> math</span> module, you can run:</p
        >
        <pre class="language-python">
<code>pydoc math</code></pre>
        <p
          >This will generate documentation for the
          <span class="language-python"> math</span> module and display it in
          the terminal.</p
        >
        <p>You can also use Pydoc to generate HTML documentation by running:</p>
        <pre class="language-python">
<code>pydoc -w math</code></pre>
        <p
          >This will generate an HTML file called
          <span class="language-python"> math.html</span> in the current
          directory, which you can then view in your web browser.</p
        >
        <h3>Using Pydoc to Explore Libraries</h3>
        <p
          >Pydoc is also a useful tool for exploring and understanding
          third-party libraries. For example, you can use Pydoc to generate
          documentation for the
          <span class="language-python"> requests</span> library, which is used
          for making HTTP requests:</p
        >
        <pre class="language-python">
<code>pydoc requests</code></pre>
        <p
          >This will generate documentation for the
          <span class="language-python"> requests</span> library and display it
          in the terminal.</p
        >
        <p
          >You can also generate HTML documentation for the
          <span class="language-python"> requests</span> library by running:</p
        >
        <pre class="language-python">
<code>pydoc -w requests</code></pre>
        <p
          >This will generate an HTML file called
          <span class="language-python"> requests.html</span> in the current
          directory, which you can then view in your web browser.</p
        >
        <h3>Conclusion</h3>
        <p
          >Pydoc is a powerful tool for generating documentation from Python
          modules, classes, and functions. By using Pydoc to generate
          documentation for your own code, as well as for exploring and
          understanding third-party libraries, you can make your code more
          accessible and easier to understand for others.</p
        >
      </article>

      <h2 class="a-main-topic">11 Popular Python Packages</h2>
      <article>
        <h2>01- Introduction (Python Packages)</h2>
        <p>
          Python has a vast collection of packages that can be used to add
          additional functionalities to your projects. These packages can help
          to reduce development time and improve the efficiency of your code.
          Here are some of the popular Python packages:
        </p>
        <ol>
          <li
            ><span>NumPy</span>: NumPy is a library for the Python programming
            language, adding support for large, multi-dimensional arrays and
            matrices, along with a large collection of high-level mathematical
            functions to operate on these arrays.</li
          >
          <li
            ><span>Pandas</span>: Pandas is a fast, powerful, flexible, and
            easy-to-use open-source data analysis and manipulation tool, built
            on top of the Python programming language.</li
          >
          <li
            ><span>Matplotlib</span>: Matplotlib is a plotting library for the
            Python programming language and its numerical mathematics extension
            NumPy.</li
          >
          <li
            ><span>Requests</span>: Requests is a simple and elegant Python HTTP
            library that makes it easy to send HTTP/1.1 requests extremely
            quickly and easily. It also supports authentication, cookies, and
            more.</li
          >
        </ol>
        <p>
          Let's look at some examples of how to use these popular Python
          packages:
        </p>
        <h3>Example 1: NumPy</h3>
        <p>
          NumPy arrays are used to store and manipulate large numerical data.
          Here is an example of how to create a NumPy array and perform
          mathematical operations on it:
        </p>
        <pre class="language-python">
<code>import numpy as np
      arr = np.array([1, 2, 3])
      print(arr)
      
      # Perform mathematical operations
      print(arr + 2)
      print(arr * 3)</code></pre>

        <h3>Example 2: Pandas</h3>
        <p>
          Pandas is used to manipulate and analyze data in Python. Here is an
          example of how to read a CSV file using Pandas and perform some basic
          analysis on it:
        </p>
        <pre class="language-python">
<code>import pandas as pd
      # Read the CSV file
      data = pd.read_csv("data.csv")
      
      # Display the first five rows of the data
      print(data.head())
      
      # Get the mean and standard deviation of the data
      print("Mean:", data["column_name"].mean())
      print("Standard Deviation:", data["column_name"].std())</code></pre>

        <h3>Example 3: Matplotlib</h3>
        <p>
          Matplotlib is used to create visualizations in Python. Here is an
          example of how to create a line plot using Matplotlib:
        </p>
        <pre class="language-python">
<code>import matplotlib.pyplot as plt
      import numpy as np
      # Create the data
      x = np.array([0, 1, 2, 3, 4])
      y = np.array([10, 20, 30, 40, 50])
      
      # Create the line plot
      plt.plot(x, y)
      
      # Show the plot
      plt.show()</code></pre>

        <h3>Example 4: Requests</h3>
        <p>
          Requests is used to send HTTP requests in Python. Here is an example
          of how to make a GET request using Requests:
        </p>
        <pre class="language-python">
<code>import requests
      # Make a GET request
      response = requests.get("https://www.example.com")
      
      # Display the response content
      print(response.content)</code></pre>
      </article>
      <article>
        <h2>02- What are APIs</h2>
        <p>
          An API, or Application Programming Interface, is a set of protocols,
          routines, and tools for building software and applications. APIs allow
          different software systems to communicate with each other, enabling
          the exchange of data and functionality between them.
        </p>
        <p>
          APIs can be used for a variety of purposes, including retrieving
          information from a server, updating data, and even controlling
          hardware. They provide a standardized way of accessing resources,
          which makes it easier for developers to create new software and
          integrate different systems.
        </p>
        <p>
          APIs are often used to access data from web services, such as social
          media platforms or weather services. To access an API, developers use
          HTTP requests to send and receive data in a specific format, such as
          JSON or XML.
        </p>
        <p>
          Here is an example of how to use the OpenWeatherMap API to retrieve
          weather data for a specific location using Python:
        </p>
        <pre class="language-python">
<code>import requests
# Set the API endpoint and parameters
url = "http://api.openweathermap.org/data/2.5/weather"
params = {
"q": "New York City",
"appid": "YOUR_API_KEY_HERE"
}

# Make a GET request to the API
response = requests.get(url, params=params)

# Check if the request was successful
if response.status_code == 200:
# Get the JSON data from the response
data = response.json()
# Extract the temperature and weather description from the data
temperature = data["main"]["temp"]
description = data["weather"][0]["description"]

# Print the temperature and weather description
print(f"The temperature in New York City is {temperature} Kelvin.")
print(f"The weather in New York City is {description}.")
else:
# Print an error message if the request was not successful
print("Error: Could not retrieve weather data.")</code></pre>

        <p>
          In this example, we first import the <code>requests</code> module,
          which allows us to send HTTP requests to the API. We then set the API
          endpoint and parameters, including the location we want to retrieve
          weather data for and our API key. We make a GET request to the API
          using these parameters and check if the request was successful. If it
          was, we extract the temperature and weather description from the JSON
          data returned by the API and print them to the console. If it was not
          successful, we print an error message.
        </p>
        <p>
          APIs are a powerful tool for developers, allowing them to access and
          integrate a wide range of functionality and data into their
          applications. However, it's important to use APIs responsibly and
          respect the terms and conditions set by the API provider to avoid
          overloading the API and causing disruptions to other users.
        </p>
      </article>

      <article>
        <h2>03- Yelp API</h2>
        <p>
          Yelp is a popular website and app that provides crowd-sourced reviews
          of local businesses. The Yelp API allows developers to access Yelp's
          database of businesses, reviews, and other data, and incorporate it
          into their own applications.
        </p>
        <p>
          To use the Yelp API, developers need to create an account and obtain
          an API key. The API uses OAuth 1.0a authentication, which involves
          signing requests with a set of keys and tokens to ensure that only
          authorized users can access the API. Developers also need to agree to
          Yelp's API terms of use and attribution requirements.
        </p>
        <p>
          Here is an example of how to use the Yelp API to search for businesses
          in a specific location and category using Python:
        </p>
        <pre class="language-python">
<code>import requests
import json
# Set the API endpoint and parameters
url = "https://api.yelp.com/v3/businesses/search"
params = {
"location": "New York City",
"categories": "coffee",
"limit": 10
}

# Set the API headers with your Yelp API key
headers = {
"Authorization": "Bearer YOUR_API_KEY_HERE"
}

# Make a GET request to the API
response = requests.get(url, params=params, headers=headers)

# Check if the request was successful
if response.status_code == 200:
# Get the JSON data from the response
data = json.loads(response.text)
# Print the name and rating of each business
for business in data["businesses"]:
    print(f"{business['name']} - {business['rating']}")
    else:
    # Print an error message if the request was not successful
    print("Error: Could not retrieve business data.")</code></pre>

        <p>
          In this example, we first import the <code>requests</code> and
          <code>json</code> modules. We then set the API endpoint and
          parameters, including the location we want to search for businesses
          in, the category of businesses we are interested in (in this case,
          coffee shops), and the maximum number of results we want to retrieve.
          We set the API headers with our Yelp API key and make a GET request to
          the API using these parameters. We check if the request was
          successful, and if it was, we extract the name and rating of each
          business from the JSON data returned by the API and print them to the
          console. If it was not successful, we print an error message.
        </p>
        <p>
          The Yelp API is a powerful tool for developers looking to incorporate
          local business data into their applications. However, it's important
          to use the API responsibly and respect Yelp's terms of use to avoid
          overloading the API and causing disruptions to other users.
        </p>
      </article>
      <article>
        <h2>04- Searching for Businesses</h2>
        <p>
          One of the most common uses of the Yelp API is to search for
          businesses in a specific location and category. This can be done using
          the <code>businesses/search</code> endpoint of the Yelp API, which
          allows developers to specify various parameters such as location,
          categories, price range, and more to refine their search results.
        </p>
        <p>
          Here's an example of how to search for coffee shops in New York City
          using the Yelp API and the <code>requests</code> library in Python:
        </p>
        <pre class="language-python">
<code>import requests
      import json
      # Set the API endpoint and parameters
      url = "https://api.yelp.com/v3/businesses/search"
      params = {
      "term": "coffee",
      "location": "New York City",
      "categories": "coffee",
      "limit": 10
      }
      
      # Set the API headers with your Yelp API key
      headers = {
      "Authorization": "Bearer YOUR_API_KEY_HERE"
      }
      
      # Make a GET request to the API
      response = requests.get(url, params=params, headers=headers)
      
      # Check if the request was successful
      if response.status_code == 200:
      # Get the JSON data from the response
      data = json.loads(response.text)
      
      # Print the name and rating of each business
      for business in data["businesses"]:
          print(f"{business['name']} - {business['rating']}")
      else:
      # Print an error message if the request was not successful
      print("Error: Could not retrieve business data.")</code></pre>

        <p>
          In this example, we set the <code>term</code> parameter to "coffee" to
          search for coffee-related businesses, and the
          <code>location</code> parameter to "New York City" to search for
          businesses in that location. We also set the
          <code>categories</code> parameter to "coffee" to ensure that we only
          get results for coffee shops rather than other types of businesses
          that may serve coffee. Finally, we set the
          <code>limit</code> parameter to 10 to limit the number of results
          returned by the API.
        </p>
        <p>
          After setting the API endpoint, parameters, and headers with our Yelp
          API key, we make a GET request to the API using the
          <code>requests.get()</code> method. We then check if the request was
          successful using the <code>response.status_code</code> property, and
          if it was, we extract the name and rating of each business from the
          JSON data returned by the API and print them to the console. If the
          request was not successful, we print an error message.
        </p>
        <p>
          This is just a simple example of how to search for businesses using
          the Yelp API. There are many other parameters and options that
          developers can use to customize their search results, such as sorting
          by distance or rating, filtering by price range or open hours, and
          more.
        </p>
      </article>
      <article>
        <h2>05- Hiding API Keys</h2>
        <p>
          When working with APIs, it's important to keep your API keys and other
          sensitive information secure. This is especially true for the Yelp
          API, which requires developers to authenticate their requests with an
          API key in order to access the API's data.
        </p>
        <p>
          One common way to keep API keys secure is to store them in environment
          variables rather than hardcoding them into your code. This makes it
          easier to manage and update your API keys without having to modify
          your code every time. Here's an example of how to do this using the
          <code>dotenv</code> library in Python:
        </p>
        <pre class="language-python">
<code>import os
      from dotenv import load_dotenv
      # Load the .env file containing your API key
      load_dotenv()
      api_key = os.getenv("YELP_API_KEY")
      
      # Set the API endpoint and parameters
      url = "https://api.yelp.com/v3/businesses/search"
      params = {
      "term": "coffee",
      "location": "New York City",
      "categories": "coffee",
      "limit": 10
      }
      
      # Set the API headers with your Yelp API key
      headers = {
      "Authorization": f"Bearer {api_key}"
      }
      
      # Make a GET request to the API
      response = requests.get(url, params=params, headers=headers)
      
      # Check if the request was successful
      if response.status_code == 200:
      # Get the JSON data from the response
      data = json.loads(response.text)

      # Print the name and rating of each business
      for business in data["businesses"]:
          print(f"{business['name']} - {business['rating']}")
      else:
      # Print an error message if the request was not successful
      print("Error: Could not retrieve business data.")</code></pre>

        <p>
          In this example, we use the <code>os.getenv()</code> function to
          retrieve the value of our Yelp API key from an environment variable
          called "YELP_API_KEY". We load this variable from a .env file using
          the <code>load_dotenv()</code> function from the
          <code>dotenv</code> library. This file should be stored in the same
          directory as your Python script, and should contain a line like this:
        </p>
        <pre><code>YELP_API_KEY=YOUR_API_KEY_HERE</code></pre>
        <p>
          By storing our API key in an environment variable, we can keep it
          secure and easily manage it across multiple scripts and projects. Be
          sure to add the .env file to your .gitignore file if you're using
          version control to prevent your API key from being accidentally
          committed to your repository.
        </p>
      </article>
      <article>
        <h2>06- Sending Text Messages</h2>
        <p>
          The ability to send text messages programmatically can be a useful
          feature for a wide variety of applications, such as notification
          systems, alerts, and reminders. In this note, we will demonstrate how
          to use the Twilio API to send text messages using Python.
        </p>
        <p>
          First, you'll need to sign up for a free Twilio account and get your
          account SID and authentication token. You'll also need to purchase a
          phone number that you can use to send text messages. Once you have
          these, you can install the <code>twilio</code> library using pip:
        </p>
        <pre><code>pip install twilio</code></pre>
        <p>
          Once you've installed the Twilio library, you can use it to send text
          messages like this:
        </p>
        <pre class="language-python">
<code>from twilio.rest import Client
      # Your Twilio account SID and authentication token
      account_sid = "YOUR_ACCOUNT_SID"
      auth_token = "YOUR_AUTH_TOKEN"
      
      # The Twilio phone number you purchased
      from_phone = "+1234567890"
      
      # The destination phone number
      to_phone = "+0987654321"
      
      # The message you want to send
      message = "Hello from Twilio!"
      
      # Create a Twilio client object
      client = Client(account_sid, auth_token)
      
      # Send the message using the Twilio client
      message = client.messages.create(
      body=message,
      from_=from_phone,
      to=to_phone
      )
      
      # Print the message SID
      print(f"Message SID: {message.sid}")</code></pre>

        <p>
          In this example, we import the <code>Client</code> class from the
          <code>twilio.rest</code> module and create a new instance of the
          client by passing in our Twilio account SID and authentication token.
          We then use the <code>create()</code> method of the
          <code>client.messages</code> object to send a text message to the
          specified destination phone number from our Twilio phone number.
        </p>
        <p>
          Note that Twilio does charge for sending text messages, but you can
          send a limited number of messages for free when using a trial account.
          You can find more information about Twilio pricing on their website.
        </p>
      </article>
      <article>
        <h2>07- Web Scraping</h2>
        <p>
          Web scraping is the process of extracting data from websites. Python
          has several packages that make web scraping easy, including
          <code>beautifulsoup4</code> and <code>requests</code>. In this note,
          we will show you how to use these packages to scrape data from a
          website.
        </p>
        <p> First, you'll need to install the packages using pip: </p>
        <pre><code>pip install beautifulsoup4 requests</code></pre>
        <p>
          Next, we'll use the <code>requests</code> package to send an HTTP
          request to a web page and get the HTML content. Here's an example:
        </p>
        <pre class="language-python">
<code>import requests
      url = "https://www.example.com"
      response = requests.get(url)
      
      print(response.text)</code></pre>

        <p>
          In this example, we import the <code>requests</code> package and use
          the <code>get()</code> method to send a request to the specified URL.
          We then print the HTML content of the response using the
          <code>text</code> attribute.
        </p>
        <p>
          Once we have the HTML content, we can use the
          <code>beautifulsoup4</code> package to parse the HTML and extract the
          data we're interested in. Here's an example:
        </p>
        <pre class="language-python">
<code>from bs4 import BeautifulSoup
      soup = BeautifulSoup(response.text, "html.parser")
      
      # Find all the links on the page
      links = soup.find_all("a")
      
      # Print the URLs of the links
      for link in links:
      print(link.get("href"))</code></pre>

        <p>
          In this example, we import the <code>BeautifulSoup</code> class from
          the <code>bs4</code> module and create a new instance of the class by
          passing in the HTML content and specifying the parser to use. We then
          use the <code>find_all()</code> method to find all the
          <code>&lt;a&gt;</code> tags on the page and print the URLs of the
          links using the <code>get()</code> method of each tag.
        </p>
        <p>
          Note that web scraping can be a controversial practice, so it's
          important to be respectful of website terms of service and robots.txt
          files. Some websites may also use measures like CAPTCHAs to prevent
          automated scraping. Be sure to check the website's policies and use
          common sense when scraping data.
        </p>
      </article>
      <article>
        <h2>08- Browser Automation</h2>
        <p>
          Browser automation refers to the process of programmatically
          interacting with a web browser to perform tasks such as filling out
          forms, clicking buttons, and navigating between pages. Python has
          several packages that allow you to automate web browsers, including
          <code>selenium</code> and <code>pyautogui</code>. In this note, we
          will focus on the <code>selenium</code> package, which provides a
          powerful API for browser automation.
        </p>
        <p>
          First, you'll need to install the <code>selenium</code> package using
          pip:
        </p>
        <pre><code>pip install selenium</code></pre>
        <p>
          Next, you'll need to download the appropriate web driver for the
          browser you want to automate. Selenium supports several browsers,
          including Chrome, Firefox, and Safari. You can download the web driver
          for your browser from the official Selenium website
          (https://www.selenium.dev/downloads/).
        </p>
        <p>
          Here's an example of how to use Selenium to automate a web browser:
        </p>
        <pre class="language-python">
<code>from selenium import webdriver
      # Create a new instance of the Chrome driver
      driver = webdriver.Chrome("/path/to/chromedriver")
      
      # Navigate to a web page
      driver.get("https://www.example.com")
      
      # Find an input field and type text into it
      input_field = driver.find_element_by_css_selector("input[type='text']")
      input_field.send_keys("Hello, world!")
      
      # Click a button
      button = driver.find_element_by_css_selector("button[type='submit']")
      button.click()
      
      # Close the browser
      driver.quit()</code></pre>

        <p>
          In this example, we import the <code>webdriver</code> module from the
          <code>selenium</code> package and create a new instance of the Chrome
          driver by specifying the path to the Chrome driver executable. We then
          use the <code>get()</code> method of the driver to navigate to a web
          page, use the <code>find_element_by_css_selector()</code> method to
          find an input field and a button, and interact with them using the
          <code>send_keys()</code> and <code>click()</code> methods. Finally, we
          use the <code>quit()</code> method to close the browser.
        </p>
        <p>
          Note that browser automation can be a powerful tool, but it can also
          be used for malicious purposes. Be sure to use automation responsibly
          and with respect for website terms of service and other policies.
        </p>
      </article>
      <article>
        <h2>09- Working with PDFs</h2>
        <p>
          PDF (Portable Document Format) is a popular file format for sharing
          documents. Python provides several packages for working with PDFs,
          including <code>PyPDF2</code>, <code>pdfrw</code>, and
          <code>pdfminer</code>.
        </p>
        <p>
          Here's an example of how to use the <code>PyPDF2</code> package to
          extract text from a PDF file:
        </p>
        <pre class="language-python">
<code>import PyPDF2
# Open the PDF file in read-binary mode
with open("example.pdf", "rb") as pdf_file:
# Create a PDF reader object
pdf_reader = PyPDF2.PdfFileReader(pdf_file)
# Loop over each page and extract the text
for page_num in range(pdf_reader.numPages):
  page = pdf_reader.getPage(page_num)
  text = page.extractText()

# Print the extracted text
print(f"Page {page_num + 1}")
print("-" * 40)
print(text)
print("\n")</code></pre>
        <p>
          In this example, we open the PDF file in read-binary mode using a
          <code>with</code> statement, which ensures that the file is properly
          closed when we're done with it. We then create a
          <code>PdfFileReader</code> object and loop over each page in the PDF
          using the <code>numPages</code> attribute. For each page, we extract
          the text using the <code>extractText()</code> method of the page
          object and print it to the console.
        </p>
        <p>
          The <code>PyPDF2</code> package also provides functionality for
          merging, splitting, and encrypting PDF files. Check out the official
          documentation for more information and examples
          (https://pythonhosted.org/PyPDF2/).
        </p>
      </article>
      <article>
        <h2>10- Working with Excel Spreadsheets</h2>
        <p>
          Excel spreadsheets are commonly used for data analysis and reporting.
          Python provides several packages for working with Excel files,
          including <code>openpyxl</code>, <code>xlrd</code>, and
          <code>xlsxwriter</code>.
        </p>
        <p>
          Here's an example of how to use the <code>openpyxl</code> package to
          read data from an Excel spreadsheet:
        </p>
        <pre class="language-python">
<code>import openpyxl
      # Load the workbook
      workbook = openpyxl.load_workbook("example.xlsx")
      
      # Select the worksheet
      worksheet = workbook["Sheet1"]
      
      # Loop over the rows and columns and print the values
      for row in worksheet.iter_rows(min_row=2, max_col=3):
      for cell in row:
      print(cell.value, end=" ")
      print() # Print a newline after each row</code></pre>

        <p>
          In this example, we first load the Excel workbook using the
          <code>load_workbook()</code> function, and then select the worksheet
          we want to work with using the worksheet name ("Sheet1" in this case).
          We then loop over the rows and columns of the worksheet using the
          <code>iter_rows()</code> method, which returns a generator object that
          produces <code>Cell</code> objects. We print the value of each cell to
          the console using the <code>value</code> attribute.
        </p>
        <p>
          The <code>openpyxl</code> package also provides functionality for
          creating, modifying, and saving Excel files. Check out the official
          documentation for more information and examples
          (https://openpyxl.readthedocs.io/en/stable/).
        </p>
      </article>
      <article>
        <h2>11- Command Query Separation Principle</h2>
        <p>
          The Command Query Separation (CQS) principle is a software design
          principle that states that a method or function should either be a
          command that performs an action, or a query that returns data, but not
          both. In other words, a function should do either one of the
          following:
        </p>
        <ol>
          <li>Perform an action (command)</li>
          <li>Return a value or data (query)</li>
        </ol>
        <p>
          This principle encourages the separation of concerns in software
          design and can help improve code clarity, maintainability, and
          testability. By keeping commands and queries separate, you can reduce
          the complexity of your code and make it easier to reason about.
        </p>
        <p>
          Here's an example of how you can apply the CQS principle in Python:
        </p>
        <pre class="language-python">
<code>class BankAccount:
def __init__(self, balance):
    self.balance = balance
def deposit(self, amount):
    self.balance += amount

def withdraw(self, amount):
    if amount > self.balance:
        raise ValueError("Insufficient funds")
    self.balance -= amount

def get_balance(self):
    return self.balance</code></pre>
        <p>
          In this example, we have a <code>BankAccount</code> class that has
          three methods: <code>deposit()</code>, <code>withdraw()</code>, and
          <code>get_balance()</code>. The <code>deposit()</code> and
          <code>withdraw()</code> methods are commands because they modify the
          state of the object (i.e., the account balance). The
          <code>get_balance()</code> method, on the other hand, is a query
          because it returns the current balance of the account without
          modifying the object state.
        </p>
        <p>
          By separating commands and queries in this way, we can make our code
          more readable, easier to test, and less error-prone. The CQS principle
          is just one of many design principles that can help you write better
          code and build more maintainable software systems.
        </p>
      </article>
      <article>
        <h2>12- NumPy</h2>
        <p>
          NumPy (Numerical Python) is a popular open-source Python library used
          for scientific computing and data analysis. It provides powerful tools
          for working with arrays, matrices, and numerical computations. NumPy
          is built on top of the C programming language, which gives it superior
          performance and efficiency compared to pure Python implementations.
        </p>
        <p>
          One of the key features of NumPy is its powerful array and matrix
          operations. NumPy arrays are similar to Python lists, but with
          additional capabilities for performing element-wise operations, vector
          and matrix operations, and broadcasting. Here's an example of how to
          create a NumPy array:
        </p>
        <pre class="language-python">
<code>import numpy as np
# Create a 1D array
a = np.array([1, 2, 3, 4, 5])

# Create a 2D array
b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</code></pre>

        <p>
          NumPy also provides many built-in functions for performing
          mathematical and statistical computations, such as mean, median, sum,
          standard deviation, and more. Here's an example of how to use some of
          these functions:
        </p>
        <pre class="language-python">
<code>import numpy as np
# Create a 1D array
a = np.array([1, 2, 3, 4, 5])

# Compute the mean
mean = np.mean(a)

# Compute the standard deviation
std = np.std(a)

# Compute the sum
sum = np.sum(a)</code></pre>

        <p>
          NumPy also provides many functions for working with matrices, such as
          matrix multiplication, inverse, and determinant. Here's an example of
          how to multiply two matrices using NumPy:
        </p>
        <pre class="language-python">
<code>import numpy as np
# Create two matrices
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6], [7, 8]])

# Multiply the matrices
c = np.dot(a, b)</code></pre>

        <p>
          NumPy is a powerful library for scientific computing and data analysis
          in Python. Its array and matrix operations, mathematical and
          statistical functions, and efficient implementation make it an
          essential tool for many applications in fields such as machine
          learning, data science, and engineering.
        </p>
      </article>

      <h2 class="a-main-topic">12 Building Web Applications with Django</h2>
      <article>
        <h2>01- Introduction</h2>
        <p
          >Building Web Applications with Django is an essential skill for web
          developers. Django is a powerful Python-based web framework that
          allows developers to quickly and efficiently build web applications.
          Django provides a variety of tools and modules to help developers
          create web applications that are secure, scalable, and maintainable.
        </p>
        <p
          >In this course, you will learn how to create web applications using
          Django. You will learn about the Django architecture, models, views,
          templates, and URL routing. You will also learn how to use Django's
          built-in authentication system and how to create custom user
          models.</p
        >
        <p
          >To get started with Django, you need to have Python installed on your
          computer. You can install Django using pip, the Python package
          manager.</p
        >
        <pre class="language-python">
<code>pip install Django</code></pre>
        <p
          >Once Django is installed, you can create a new Django project using
          the following command:</p
        >
        <pre
          class="language-python"
        ><code>django-admin startproject myproject</code></pre>
        <p
          >This command will create a new directory called 'myproject' with the
          following structure:</p
        >
        <pre><code>
          myproject/
              manage.py
              myproject/
                  __init__.py
                  settings.py
                  urls.py
                  asgi.py
                  wsgi.py
        </code></pre>
        <p
          >The 'manage.py' file is used to manage your Django project, and the
          'settings.py' file contains the settings for your project. The
          'urls.py' file contains the URL routing for your project.</p
        >
      </article>
      <article>
        <h2>02- Your First Django Project</h2>
        <p
          >Once you have installed Django, you can start your first Django
          project by following these steps:</p
        >
        <ol>
          <li
            >Open a command prompt or terminal and navigate to the directory
            where you want to create your project.</li
          >
          <li>Create a new Django project using the following command:</li>
        </ol>
        <pre
          class="language-python"
        ><code>django-admin startproject myproject</code></pre>
        <p>Replace 'myproject' with the name of your project.</p>
        <ol start="3">
          <li>Navigate to the project directory:</li>
        </ol>
        <pre class="language-python">
<code>cd myproject</code></pre>
        <ol start="4">
          <li>Run the development server:</li>
        </ol>
        <pre
          class="language-python"
        ><code>python manage.py runserver</code></pre>
        <p>This will start the development server at http://127.0.0.1:8000/.</p>
        <p
          >If you open this URL in a web browser, you should see a message that
          says "Welcome to Django". This means that your Django project is
          working correctly.</p
        >
        <p
          >You can now start creating your Django application. An application is
          a collection of related code that performs a specific task, such as a
          blog or a forum.</p
        >
        <ol start="5">
          <li>Create a new Django application using the following command:</li>
        </ol>
        <pre
          class="language-python"
        ><code>python manage.py startapp myapp</code></pre>
        <p>Replace 'myapp' with the name of your application.</p>
        <p
          >This will create a new directory called 'myapp' with the following
          structure:</p
        >
        <pre><code>
          myapp/
              __init__.py
              admin.py
              apps.py
              models.py
              tests.py
              views.py
        </code></pre>
        <p
          >The 'models.py' file is used to define the database schema for your
          application, and the 'views.py' file contains the logic for your
          application.</p
        >
        <p
          >You can now start building your Django application by adding models,
          views, and templates.</p
        >
      </article>
      <article>
        <h2>03- Your First App</h2>
        <p
          >After creating a new Django project, the next step is to create a new
          app within the project. An app is a self-contained module that
          performs a specific task, such as managing a blog or an e-commerce
          site.</p
        >
        <p>To create a new app, follow these steps:</p>
        <ol>
          <li
            >Open a command prompt or terminal and navigate to the project
            directory.</li
          >
          <li>Create a new app using the following command:</li>
        </ol>
        <pre
          class="language-python"
        ><code>python manage.py startapp myapp</code></pre>
        <p>Replace 'myapp' with the name of your app.</p>
        <p
          >This will create a new directory called 'myapp' with the following
          structure:</p
        >
        <pre><code>
          myapp/
              __init__.py
              admin.py
              apps.py
              models.py
              tests.py
              views.py
        </code></pre>
        <p
          >The 'models.py' file is used to define the database schema for your
          app, and the 'views.py' file contains the logic for your app.</p
        >
        <ol start="3">
          <li
            >Register the app with the project by adding it to the
            INSTALLED_APPS list in the 'settings.py' file:</li
          >
        </ol>
        <pre><code>
          INSTALLED_APPS = [
              ...
              'myapp',
          ]
        </code></pre>
        <p
          >Now that the app is registered with the project, you can start
          building it by creating models, views, and templates.</p
        >
        <p
          >For example, you can create a simple view in 'views.py' that returns
          a "Hello, World!" message:</p
        >
        <pre><code>
from django.http import HttpResponse
def hello(request):
  return HttpResponse("Hello, World!")
</code></pre>

        <p
          >You can then create a URL pattern in 'urls.py' that maps the URL
          '/hello/' to the 'hello' view:</p
        >
        <pre><code>
from django.urls import path
from . import views
urlpatterns = [    path('hello/', views.hello, name='hello'),]
</code></pre>

        <p
          >Finally, you can create a template in 'templates/myapp/hello.html'
          that displays the "Hello, World!" message:</p
        >
        <pre><code>
  &lt;h1&gt;{{ message }}&lt;/h1&gt;
</code></pre>
        <p>You can then modify the 'hello' view to render the template:</p>
        <pre><code>
from django.shortcuts import render
def hello(request):
  message = "Hello, World!"
  return render(request, 'myapp/hello.html', {'message': message})
</code></pre>

        <p
          >If you navigate to http://127.0.0.1:8000/hello/, you should see the
          "Hello, World!" message displayed in the browser.</p
        >
      </article>
      <article>
        <h2>04- Views</h2>
        <p
          >In Django, a view is a Python function that takes a web request and
          returns a web response. The response can be the HTML contents of a web
          page, or a redirect to another URL, or a JSON-encoded object, or
          anything else.</p
        >
        <p>To create a view, follow these steps:</p>
        <ol>
          <li
            >Create a new function in 'views.py' that takes a request parameter
            and returns an HTTP response:</li
          >
        </ol>
        <pre><code>
          from django.http import HttpResponse
      def my_view(request):
          return HttpResponse('Hello, World!')
      </code></pre>

        <p
          >This is a very simple view that just returns a "Hello, World!"
          message as an HTTP response.</p
        >
        <ol start="2">
          <li
            >Create a URL pattern in 'urls.py' that maps a URL to your view:</li
          >
        </ol>
        <pre><code>
          from django.urls import path
          from . import views
      urlpatterns = [    path('my_view/', views.my_view, name='my_view'),]
      </code></pre>

        <p>This URL pattern maps the URL '/my_view/' to the 'my_view' view.</p>
        <p>You can also pass parameters to your views using URL patterns:</p>
        <pre><code>
          urlpatterns = [
              path('my_view/&lt;str:name&gt;/', views.my_view, name='my_view'),
          ]
        </code></pre>
        <p
          >This URL pattern maps the URL '/my_view/john/' to the 'my_view' view,
          passing the string 'john' as a parameter.</p
        >
        <p
          >Inside your views, you can access these parameters using the
          'request' object:</p
        >
        <pre><code>
          def my_view(request, name):
              return HttpResponse(f'Hello, {name}!')
        </code></pre>
        <p
          >Now, if you navigate to http://127.0.0.1:8000/my_view/john/, you
          should see the message "Hello, john!" displayed in the browser.</p
        >
        <p
          >In addition to returning HTTP responses, views can also render
          templates using the 'render' function:</p
        >
        <pre><code>
          from django.shortcuts import render
      def my_view(request):
          name = 'John'
          return render(request, 'my_template.html', {'name': name})
      </code></pre>

        <p
          >This view renders the 'my_template.html' template, passing the
          variable 'name' to the template.</p
        >
        <p
          >Templates are HTML files that define the structure and layout of your
          web pages. You can use template tags to insert dynamic content into
          your templates:</p
        >
        <pre><code>
          &lt;html&gt;
          &lt;head&gt;
              &lt;title&gt;My Page&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
              &lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt;
          &lt;/body&gt;
          &lt;/html&gt;
        </code></pre>
        <p
          >This template displays the "Hello, {{ name }}!" message, with the
          value of the 'name' variable substituted in.</p
        >
      </article>
      <article>
        <h2>05- Models</h2>
        <p
          >In Django, a model is a Python class that represents a database
          table. Each attribute of the class represents a column in the table,
          and each instance of the class represents a row in the table.</p
        >
        <p>To create a model, follow these steps:</p>
        <ol>
          <li
            >Create a new class in 'models.py' that inherits from
            'django.db.models.Model':</li
          >
        </ol>
        <pre><code>
          from django.db import models
      class Person(models.Model):
          first_name = models.CharField(max_length=30)
          last_name = models.CharField(max_length=30)
          email = models.EmailField(max_length=254)
      </code></pre>

        <p
          >This model represents a database table with three columns:
          'first_name', 'last_name', and 'email'.</p
        >
        <ol start="2">
          <li>Create a migration for the model:</li>
        </ol>
        <pre><code>
          python manage.py makemigrations
        </code></pre>
        <p
          >This command creates a migration file that tells Django how to create
          the table in the database.</p
        >
        <ol start="3">
          <li>Apply the migration:</li>
        </ol>
        <pre><code>
          python manage.py migrate
        </code></pre>
        <p
          >This command runs the migration and creates the table in the
          database.</p
        >
        <p
          >Now you can use the model to create, read, update, and delete records
          in the database:</p
        >
        <pre><code>
          # create a new record
          person = Person(first_name='John', last_name='Doe', email='john@example.com')
          person.save()
      # read all records
      people = Person.objects.all()
      
      # read a single record
      person = Person.objects.get(pk=1)
      
      # update a record
      person.first_name = 'Jane'
      person.save()
      
      # delete a record
      person.delete()
      </code></pre>

        <p
          >You can also define relationships between models, such as one-to-one,
          one-to-many, and many-to-many:</p
        >
        <pre><code>
          class Book(models.Model):
              title = models.CharField(max_length=100)
              author = models.ForeignKey(Person, on_delete=models.CASCADE)
              readers = models.ManyToManyField(Person, related_name='books_read')
      class Movie(models.Model):
          title = models.CharField(max_length=100)
          director = models.ForeignKey(Person, on_delete=models.CASCADE)
      </code></pre>

        <p
          >This model defines a one-to-many relationship between 'Person' and
          'Book', and a many-to-many relationship between 'Person' and
          'Movie'.</p
        >
        <p>You can use these relationships to query related records:</p>
        <pre><code>
          # get all books by John Doe
          books = Book.objects.filter(author__first_name='John', author__last_name='Doe')
      # get all movies watched by John Doe
      movies = Movie.objects.filter(readers__first_name='John', readers__last_name='Doe')
      </code></pre>

        <p
          >Models are a powerful tool for working with databases in Django, and
          can make it easy to build complex web applications.</p
        >
      </article>
      <article>
        <h2>06- Migrations</h2>
        <p
          >Migrations are Django's way of propagating changes you make to your
          models (adding a field, deleting a model, etc.) into your database
          schema. They're designed to be mostly automatic, but you'll need to
          know when to make migrations, when to run them, and the common
          problems you might run into.</p
        >
        <p>Here's an overview of how migrations work in Django:</p>
        <ol>
          <li>Create a new model or modify an existing one in 'models.py'.</li>
          <li>Create a migration for the changes:</li>
        </ol>
        <pre><code>
          python manage.py makemigrations
        </code></pre>
        <p
          >This will generate a new migration file in the 'migrations' directory
          of your app.</p
        >
        <ol start="3">
          <li>Review the migration file to make sure it looks correct.</li>
          <li>Apply the migration:</li>
        </ol>
        <pre><code>
          python manage.py migrate
        </code></pre>
        <p
          >This will update your database schema to match the changes you made
          in your models.</p
        >
        <p
          >Here are some common problems you might encounter with migrations:</p
        >
        <ul>
          <li
            ><strong>Conflicts:</strong> If two developers modify the same model
            at the same time, there may be conflicts in the migration files.
            You'll need to resolve these conflicts manually.</li
          >
          <li
            ><strong>Migration dependencies:</strong> If you have multiple apps
            with interdependent models, you'll need to make sure that the
            migrations are applied in the correct order.</li
          >
          <li
            ><strong>Rolling back migrations:</strong> If you need to undo a
            migration, you can use the 'migrate' command with the name of the
            migration you want to roll back to:</li
          >
        </ul>
        <pre><code>
          python manage.py migrate myapp 0003
        </code></pre>
        <p
          >This will roll back all migrations after '0003' in the 'myapp'
          app.</p
        >
        <p
          >Overall, migrations are an essential tool for managing database
          changes in Django, and can help ensure that your database schema stays
          in sync with your application's models.</p
        >
      </article>
      <article>
        <h2>07- Changing the Models</h2>
        <p
          >As your application grows, you'll likely need to make changes to your
          models to add new functionality or improve performance. Here are some
          common types of changes you might need to make:</p
        >
        <ul>
          <li
            ><strong>Adding a field:</strong> To add a new field to a model,
            simply add a new attribute to the class in 'models.py'. Then, create
            a migration and apply it:</li
          >
        </ul>
        <pre><code>
          # models.py
          class MyModel(models.Model):
              name = models.CharField(max_length=100)
              new_field = models.BooleanField(default=False)
      python manage.py makemigrations
      python manage.py migrate
      </code></pre>

        <ul>
          <li
            ><strong>Removing a field:</strong> To remove a field, simply remove
            the attribute from the class and create a migration:</li
          >
        </ul>
        <pre><code>
          # models.py
          class MyModel(models.Model):
              name = models.CharField(max_length=100)
      python manage.py makemigrations
      python manage.py migrate
      </code></pre>

        <ul>
          <li
            ><strong>Changing a field:</strong> To change a field's properties,
            such as its data type or maximum length, modify the attribute in the
            class and create a migration:</li
          >
        </ul>
        <pre><code>
          # models.py
          class MyModel(models.Model):
              name = models.CharField(max_length=200)
      python manage.py makemigrations
      python manage.py migrate
      </code></pre>

        <p
          >Note that some changes may require more complex migrations, such as
          creating new tables or altering existing ones. In these cases, you may
          need to write custom migration code.</p
        >
        <p
          >It's also important to keep in mind that any changes you make to your
          models will affect the data in your database. If you're making
          significant changes, be sure to back up your data before running
          migrations.</p
        >
      </article>
      <article>
        <h2>08- Admin</h2>
        <p
          >Django provides a built-in administration interface that allows you
          to manage your application's data without writing any custom views or
          templates. The administration interface is generated based on your
          models, and you can customize it to suit your needs.</p
        >
        <p
          >To access the administration interface, you need to create a
          superuser account:</p
        >
        <pre><code>python manage.py createsuperuser</code></pre>
        <p
          >Once you have created a superuser, you can access the administration
          interface by visiting '/admin' in your browser and logging in.</p
        >
        <p
          >To customize the administration interface, you can define a
          ModelAdmin class in your app's 'admin.py' file. Here's an example:</p
        >
        <pre><code>
          # admin.py
          from django.contrib import admin
          from .models import MyModel
      class MyModelAdmin(admin.ModelAdmin):
          list_display = ('name', 'created_at')
          list_filter = ('created_at',)
          search_fields = ('name',)
      
      admin.site.register(MyModel, MyModelAdmin)
      </code></pre>

        <p
          >In this example, we define a ModelAdmin class for our 'MyModel'
          model. We specify which fields to display in the list view ('name' and
          'created_at'), which filters to provide ('created_at'), and which
          fields to search on ('name'). We then register the model with the
          administration site and pass our custom ModelAdmin class.</p
        >
        <p
          >There are many other customization options available for the
          administration interface, including custom templates, custom form
          widgets, and custom validation. Check out the Django documentation for
          more information.</p
        >
      </article>
      <article>
        <h2>09- Customizing the Admin</h2>
        <p
          >In addition to defining a ModelAdmin class to customize the
          administration interface for a specific model, you can also customize
          the overall look and feel of the administration interface by providing
          your own templates and static files.</p
        >
        <p
          >To customize the templates used by the administration interface,
          create a 'templates/admin' directory in your app and add your own
          templates. For example, to customize the change form template for the
          'MyModel' model, create a file called 'mymodel_change_form.html' in
          the 'templates/admin' directory:</p
        >
        <pre><code>
          {% extends "admin/change_form.html" %}
      {% block extrahead %}
          &lt;!-- Custom CSS here -->
      {% endblock %}
      
      {% block content %}
          &lt;h1>Custom heading here&lt;/h1>
          {{ block.super }}
          &lt;!-- Custom HTML here -->
      {% endblock %}
      </code></pre>

        <p
          >In this example, we extend the default 'change_form.html' template
          provided by Django and add our own custom CSS and HTML. We also
          include the 'block.super' template tag to include the default content
          provided by Django.</p
        >
        <p
          >To customize the static files used by the administration interface,
          create a 'static/admin' directory in your app and add your own static
          files. For example, to customize the CSS used by the administration
          interface, create a file called 'mystyle.css' in the
          'static/admin/css' directory:</p
        >
        <pre><code>
          /* mystyle.css */
          body {
              background-color: #f0f0f0;
          }
        </code></pre>
        <p
          >In this example, we set the background color of the body element to
          light gray.</p
        >
        <p
          >By customizing the templates and static files used by the
          administration interface, you can create a custom look and feel that
          matches the branding of your application.</p
        >
      </article>
      <article>
        <h2>10- Database Abstraction API</h2>
        <p
          >The Django database abstraction API provides a high-level,
          database-independent interface for working with databases. This means
          that you can write your application code without worrying about the
          specific details of the database backend you are using.</p
        >
        <p
          >The Django database abstraction API supports several database
          backends, including PostgreSQL, MySQL, SQLite, and Oracle. It provides
          a consistent API for creating, reading, updating, and deleting data,
          regardless of the database backend you are using.</p
        >
        <p
          >To use the database abstraction API, you define models that map to
          database tables. Each model represents a single table in your database
          and provides a high-level interface for working with the data in that
          table. Here's an example:</p
        >
        <pre><code>
          from django.db import models
      class MyModel(models.Model):
          name = models.CharField(max_length=50)
          age = models.IntegerField()
          created_at = models.DateTimeField(auto_now_add=True)
      
          def __str__(self):
              return self.name
      </code></pre>

        <p
          >In this example, we define a 'MyModel' model that maps to a database
          table with three columns: 'name', 'age', and 'created_at'. We also
          define a '__str__' method that returns the name of the model
          instance.</p
        >
        <p
          >Once you have defined your models, you can use the database
          abstraction API to create, read, update, and delete data. Here are
          some examples:</p
        >
        <pre><code>
          # create a new MyModel instance
          my_instance = MyModel.objects.create(name='John Doe', age=30)
      # retrieve all MyModel instances
      all_instances = MyModel.objects.all()
      
      # retrieve a single MyModel instance
      single_instance = MyModel.objects.get(name='John Doe')
      
      # update a MyModel instance
      my_instance.age = 31
      my_instance.save()
      
      # delete a MyModel instance
      my_instance.delete()
      </code></pre>

        <p
          >In this example, we create a new 'MyModel' instance, retrieve all
          instances, retrieve a single instance, update an instance, and delete
          an instance.</p
        >
        <p
          >The Django database abstraction API provides many more features and
          options for working with databases. Check out the Django documentation
          for more information.</p
        >
      </article>
      <article>
        <h2>11- Templates</h2>
        <p
          >Django's template system allows you to define the structure and
          layout of your HTML pages in a separate file called a template. This
          separation of concerns allows you to keep your HTML and Python code
          separate, which can make it easier to maintain your codebase over
          time.</p
        >
        <p>Here's an example of a simple template:</p>
        <pre><code>
          &lt;!DOCTYPE html&gt;
          &lt;html&gt;
          &lt;head&gt;
              &lt;title&gt;{{ title }}&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
              &lt;h1&gt;{{ heading }}&lt;/h1&gt;
              &lt;p&gt;{{ content }}&lt;/p&gt;
          &lt;/body&gt;
          &lt;/html&gt;
        </code></pre>
        <p
          >In this example, we define a basic HTML page with a title, a heading,
          and some content. The interesting part is the use of double curly
          braces '{{ }}' to denote placeholders in the template. These
          placeholders will be replaced with actual values when the template is
          rendered.</p
        >
        <p
          >To render a template in Django, you need to define a view that will
          provide the data for the template and render the template itself.
          Here's an example:</p
        >
        <pre><code>
          from django.shortcuts import render
      def my_view(request):
          context = {
              'title': 'My Page',
              'heading': 'Welcome to my page!',
              'content': 'This is some content for my page.'
          }
          return render(request, 'my_template.html', context)
      </code></pre>

        <p
          >In this example, we define a 'my_view' function that provides the
          data for our template. We create a dictionary called 'context' that
          contains the values we want to substitute into our template. We then
          call the 'render' function with our request object, the name of our
          template file, and our context dictionary. The 'render' function will
          substitute the values from the 'context' dictionary into our template
          and return the resulting HTML.</p
        >
        <p
          >There are many more features and options available in Django's
          template system, including conditional statements, loops, and filters.
          Check out the Django documentation for more information.</p
        >
      </article>
      <article>
        <h2>12- Adding Bootstrap</h2>
        <p
          >Bootstrap is a popular front-end framework for building responsive,
          mobile-first websites. It provides a set of CSS and JavaScript
          components that can be used to quickly create stylish and responsive
          web pages.</p
        >
        <p
          >To add Bootstrap to your Django project, you can follow these
          steps:</p
        >
        <ol>
          <li
            >Download the Bootstrap files from the official website or use a CDN
            link.</li
          >
          <li
            >Create a new directory called 'static' in your Django project
            directory. This directory will hold all of your static files (CSS,
            JavaScript, images, etc.)</li
          >
          <li
            >Create a new directory called 'css' inside the 'static'
            directory.</li
          >
          <li
            >Move the Bootstrap CSS file (bootstrap.css or bootstrap.min.css)
            into the 'css' directory.</li
          >
          <li
            >Create a new directory called 'js' inside the 'static'
            directory.</li
          >
          <li
            >Move the Bootstrap JavaScript file (bootstrap.js or
            bootstrap.min.js) into the 'js' directory.</li
          >
          <li
            >In your Django template, include the Bootstrap CSS and JavaScript
            files using the 'link' and 'script' tags:</li
          >
        </ol>
        <pre><code>
          &lt;!DOCTYPE html&gt;
          &lt;html&gt;
          &lt;head&gt;
              &lt;title&gt;My Page&lt;/title&gt;
              &lt;link rel="stylesheet" href="{% static 'css/bootstrap.min.css' %}"&gt;
          &lt;/head&gt;
          &lt;body&gt;
              &lt;h1&gt;My Page&lt;/h1&gt;
              &lt;p&gt;This is my page.&lt;/p&gt;
              &lt;script src="{% static 'js/bootstrap.min.js' %}"&gt;&lt;/script&gt;
          &lt;/body&gt;
          &lt;/html&gt;
        </code></pre>
        <p
          >In this example, we use the 'static' template tag to reference the
          Bootstrap CSS and JavaScript files in our 'css' and 'js' directories,
          respectively. The 'static' tag is used to generate the correct URL for
          the static files, which will depend on the configuration of your
          Django project.</p
        >
        <p
          >Once you have included the Bootstrap files in your template, you can
          start using the Bootstrap components and classes to style your HTML.
          For example:</p
        >
        <pre><code>
          &lt;div class="container"&gt;
              &lt;div class="row"&gt;
                  &lt;div class="col-sm-6"&gt;
                      &lt;h2&gt;My Heading&lt;/h2&gt;
                      &lt;p&gt;Some text goes here.&lt;/p&gt;
                  &lt;/div&gt;
                  &lt;div class="col-sm-6"&gt;
                      &lt;img src="my-image.jpg" class="img-responsive"&gt;
                  &lt;/div&gt;
              &lt;/div&gt;
          &lt;/div&gt;
        </code></pre>
        <p
          >In this example, we use the 'container', 'row', and 'col-sm-6'
          classes to create a responsive grid layout. We also use the
          'img-responsive' class to ensure that our image scales properly on
          different screen sizes.</p
        >
      </article>
      <article>
        <h2>13- Customizing the Layout</h2>
        <p
          >In Django, you can customize the layout of your web pages by using
          templates. Templates allow you to separate the design and layout of
          your website from the underlying code and logic.</p
        >
        <p
          >Here are the basic steps for customizing the layout of your Django
          application:</p
        >
        <ol>
          <li
            >Create a new directory called 'templates' in your application
            directory. This directory will hold all of your HTML template
            files.</li
          >
          <li
            >Create a new HTML template file for each page or section of your
            website. For example, you might create a template called 'base.html'
            that includes the common layout elements that are used on every
            page, such as the header, footer, and navigation menu. You can then
            create other templates that extend the 'base.html' template and add
            content specific to each page.</li
          >
          <li
            >In your Django view function, specify which template to use by
            using the 'render' function. For example:</li
          >
        </ol>
        <pre><code>
          from django.shortcuts import render
      def my_view(request):
          context = {'name': 'John'}
          return render(request, 'my_template.html', context)
      </code></pre>

        <p
          >In this example, we use the 'render' function to render the
          'my_template.html' template and pass in a dictionary of context
          variables ('name': 'John'). The template can then use these variables
          to generate dynamic content.</p
        >
        <p>Here is an example of a simple base template:</p>
        <pre><code>
          &lt;!DOCTYPE html&gt;
          &lt;html&gt;
          &lt;head&gt;
              &lt;title&gt;My Website&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
              &lt;nav&gt;
                  &lt;a href="/"&gt;Home&lt;/a&gt;
                  &lt;a href="/about"&gt;About&lt;/a&gt;
              &lt;/nav&gt;
              &lt;div class="content"&gt;
                  {% block content %}
                  {% endblock %}
              &lt;/div&gt;
              &lt;footer&gt;
                  &lt;p&gt;Copyright &copy; 2023&lt;/p&gt;
              &lt;/footer&gt;
          &lt;/body&gt;
          &lt;/html&gt;
        </code></pre>
        <p
          >In this template, we define a 'nav' element that contains links to
          the home and about pages, a 'div' element with a class of 'content'
          that will be used to hold the main content of each page, and a
          'footer' element with a copyright notice. We also use the 'block' tag
          to define a block called 'content' that child templates can override
          to add their own content.</p
        >
        <p
          >Here is an example of a child template that extends the 'base.html'
          template:</p
        >
        <pre><code>
          {% extends 'base.html' %}
      {% block content %}
          &lt;h1&gt;About Us&lt;/h1&gt;
          &lt;p&gt;We are a small company based in San Francisco.&lt;/p&gt;
      {% endblock %}
      </code></pre>

        <p
          >In this template, we use the 'extends' tag to specify that this
          template extends the 'base.html' template. We then use the 'block' tag
          to override the 'content' block and add our own content.</p
        >
      </article>
      <article>
        <h2>Sharing a Template Across Multiple Apps</h2>
        <p
          >In Django, it's possible to share templates between different apps.
          This is useful when you have multiple apps that need to display the
          same information in the same way. Rather than duplicating the code,
          you can create a template in a central location and then reference it
          from the other apps.</p
        >
        <p>Here are the steps to share a template:</p>
        <ol>
          <li
            >Create a folder called "templates" in the root directory of your
            project.</li
          >
          <li
            >Create a subfolder within the templates folder that has the same
            name as your app. For example, if your app is called "blog", create
            a folder called "blog" inside the "templates" folder.</li
          >
          <li
            >Create a template file within the subfolder. The name of the file
            should match the name of the view that will use it. For example, if
            you have a view called "index" in your "blog" app, create a file
            called "index.html" within the "templates/blog" folder.</li
          >
          <li
            >In your views.py file, specify the path to the template using the
            <code>render()</code> function.</li
          >
        </ol>
        <p
          >Here is an example of how to render a template that is shared between
          multiple apps:</p
        >
        <pre class="language-python">
<code>from django.shortcuts import render
      
        def index(request):
            return render(request, 'blog/index.html')</code></pre>
        <p
          >In this example, the <code>index()</code> function is rendering the
          "index.html" template from the "blog" app. If you have another app
          that needs to use the same template, you can reference it in the same
          way.</p
        >
        <p
          >Sharing templates can help keep your code organized and reduce
          duplication. It also makes it easier to update your templates if you
          need to make changes in the future.</p
        >
      </article>
      <article>
        <h2>URL Parameters</h2>
        <p
          >URL parameters are a way to pass data from the URL to the view
          function. This allows you to create dynamic views that can display
          different content based on the data passed in the URL.</p
        >
        <p
          >In Django, URL parameters are specified using angle brackets (<code
            >&lt;</code
          >
          and <code>&gt;</code>) in the URL pattern. The text between the angle
          brackets is used as the parameter name. For example:</p
        >
        <pre class="language-python">
<code>from django.urls import path
  from . import views

  urlpatterns = [
      path('articles/&lt;int:year&gt;/', views.year_archive),
  ]</code></pre>
        <p
          >In this example, the URL pattern includes a parameter called "year",
          which is an integer. When a user visits a URL that matches this
          pattern (e.g. "/articles/2021/"), Django will pass the value "2021" to
          the <code>year_archive()</code> function as a parameter.</p
        >
        <p
          >You can specify multiple parameters in a URL pattern by separating
          them with slashes. For example:</p
        >
        <pre class="language-python">
<code>urlpatterns = [
      path('articles/&lt;int:year&gt;/&lt;int:month&gt;/', views.month_archive),
  ]</code></pre>
        <p
          >In this example, the URL pattern includes two parameters called
          "year" and "month", both of which are integers. When a user visits a
          URL that matches this pattern (e.g. "/articles/2021/05/"), Django will
          pass the values "2021" and "05" to the
          <code>month_archive()</code> function as parameters.</p
        >
        <p
          >You can also use other data types for URL parameters, such as
          strings, slugs, and UUIDs. For more information on URL patterns and
          parameters, see the
          <a href="https://docs.djangoproject.com/en/3.2/topics/http/urls/"
            >Django documentation</a
          >.</p
        >
      </article>
      <article>
        <h2>Getting a Single Object</h2>
        <p
          >In Django, you can retrieve a single object from the database using
          the <code>get()</code> method of a model manager. The
          <code>get()</code> method returns a single object that matches the
          specified query parameters. If the query returns no results, a
          <code>DoesNotExist</code> exception is raised. If the query returns
          multiple results, a <code>MultipleObjectsReturned</code> exception is
          raised.</p
        >
        <p
          >Here's an example of how to retrieve a single object from the
          database:</p
        >
        <pre class="language-python">
<code>from myapp.models import MyModel

  try:
      obj = MyModel.objects.get(pk=1)
  except MyModel.DoesNotExist:
      # Handle the case where the object doesn't exist
  except MyModel.MultipleObjectsReturned:
      # Handle the case where multiple objects match the query</code></pre>
        <p
          >In this example, we're retrieving an object with a primary key (pk)
          of 1 from the <code>MyModel</code> table. If the object exists, it
          will be returned as the <code>obj</code> variable. If the object
          doesn't exist, a <code>DoesNotExist</code> exception will be raised,
          and you can handle it using a try-except block. If multiple objects
          match the query, a <code>MultipleObjectsReturned</code> exception will
          be raised, and you can handle that case as well.</p
        >
        <p
          >You can also use other query parameters to retrieve objects based on
          other fields, such as <code>name='John'</code> to retrieve objects
          with a name of "John". For more information on querying the database,
          see the
          <a href="https://docs.djangoproject.com/en/3.2/topics/db/queries/"
            >Django documentation</a
          >.</p
        >
      </article>
      <article>
        <h2>Raising 404 Errors</h2>
        <p
          >In web applications, it's common to encounter situations where a
          requested page or resource doesn't exist. In Django, you can handle
          these situations by raising a 404 error. This will cause Django to
          display the 404 page defined in your project's
          <code>TEMPLATES</code> settings.</p
        >
        <p
          >To raise a 404 error in a view, you can use the
          <code>Http404</code> exception, which is provided by Django:</p
        >
        <pre class="language-python">
<code>from django.http import Http404
from django.shortcuts import render
from myapp.models import MyModel

def my_view(request, object_id):
    try:
        obj = MyModel.objects.get(pk=object_id)
    except MyModel.DoesNotExist:
        raise Http404("Object does not exist")
    return render(request, 'my_template.html', {'object': obj})</code></pre>
        <p
          >In this example, we're trying to retrieve an object with a primary
          key of <code>object_id</code> from the <code>MyModel</code> table. If
          the object doesn't exist, we're raising a
          <code>Http404</code> exception with a custom error message. If the
          object exists, we're rendering a template with the object as
          context.</p
        >
        <p
          >You can also raise a 404 error without a custom error message by
          using the
          <code>django.shortcuts.get_object_or_404()</code> function:</p
        >
        <pre
          class="language-python"
        ><code>from django.shortcuts import get_object_or_404, render
from myapp.models import MyModel

def my_view(request, object_id):
    obj = get_object_or_404(MyModel, pk=object_id)
    return render(request, 'my_template.html', {'object': obj})</code></pre>
        <p
          >In this example, we're using the
          <code>get_object_or_404()</code> function to retrieve the object. If
          the object doesn't exist, the function will raise a
          <code>Http404</code> exception without a custom error message. If the
          object exists, the function will return the object.</p
        >
        <p
          >Raising a 404 error is important for providing a good user experience
          in your web application. By handling these errors gracefully, you can
          help users find the resources they're looking for and avoid
          frustration.</p
        >
      </article>
      <article>
        <h2>Referencing URLs</h2>
        <p
          >In Django, you can reference URLs in templates using the
          <code>{% url %}</code> template tag. This allows you to create links
          to other pages in your application without hardcoding URLs in your
          templates.</p
        >
        <p
          >The <code>{% url %}</code> tag takes one argument, which is the name
          of the URL pattern you want to reference. You can also pass additional
          arguments as keyword arguments to the tag to include them in the
          generated URL. For example, let's say you have a URL pattern defined
          in your <code>urls.py</code> file like this:</p
        >
        <pre class="language-python">
<code>from django.urls import path
from . import views

urlpatterns = [
    path('blog/&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/&lt;slug:slug&gt;/', views.blog_detail, name='blog_detail'),
]</code></pre>
        <p>You can reference this URL pattern in your template like this:</p>
        <pre
          class="language-python"
        ><code>{% url 'blog_detail' year=2019 month=1 day=1 slug='hello-world' %}</code></pre>
        <p
          >This will generate a URL like
          <code>/blog/2019/1/1/hello-world/</code>. Note that the arguments are
          passed as keyword arguments to the tag, and the URL pattern name is
          enclosed in quotes.</p
        >
        <p
          >You can also reference URLs with positional arguments using the
          <code>{% url %}</code> tag. For example, if you have a URL pattern
          like this:</p
        >
        <pre
          class="language-python"
        ><code>path('blog/&lt;int:pk&gt;/', views.blog_detail, name='blog_detail')</code></pre>
        <p>You can reference it in your template like this:</p>
        <pre
          class="language-python"
        ><code>{% url 'blog_detail' 123 %}</code></pre>
        <p
          >This will generate a URL like <code>/blog/123/</code>, where
          <code>123</code> is the value of the positional argument.</p
        >
        <p
          >Using the <code>{% url %}</code> tag to reference URLs in your
          templates is a good practice, as it makes your templates more flexible
          and easier to maintain. By keeping URLs in one place, you can make
          changes to your URL structure without having to update every link in
          your templates.</p
        >
      </article>
      <article>
        <h2>Creating APIs in Django</h2>
        <p
          >Django provides a powerful framework for creating APIs that can be
          consumed by other applications. There are several ways to create APIs
          in Django, including using Django REST framework, which is a
          third-party package that provides a set of tools and conventions for
          building APIs.</p
        >
        <h3>Django REST framework</h3>
        <p
          >Django REST framework (DRF) is a third-party package that makes it
          easy to build APIs in Django. It provides a set of tools and
          conventions for building APIs, including support for authentication,
          serialization, pagination, and filtering. To use DRF, you need to
          install it using pip:</p
        >
        <pre
          class="language-python"
        ><code>pip install djangorestframework</code></pre>
        <p
          >Once you have installed DRF, you can start building your API by
          defining serializers, views, and URLs. Serializers are used to convert
          data to JSON or other formats, views handle requests and responses,
          and URLs map requests to views. Here's an example of how to define a
          simple API using DRF:</p
        >
        <pre class="language-python">
<code># serializers.py

from rest_framework import serializers
from .models import Book

class BookSerializer(serializers.ModelSerializer):
    class Meta:
        model = Book
        fields = ['id', 'title', 'author', 'published_date', 'category']

# views.py

from rest_framework import generics
from .models import Book
from .serializers import BookSerializer

class BookList(generics.ListCreateAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer

class BookDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer

# urls.py

from django.urls import path
from .views import BookList, BookDetail

urlpatterns = [
    path('books/', BookList.as_view()),
    path('books/&lt;int:pk&gt;/', BookDetail.as_view()),
]</code></pre>
        <p
          >In this example, we define a serializer for our Book model, which has
          fields for the book's ID, title, author, published date, and category.
          We also define two views, one for listing all books and creating new
          ones, and another for retrieving, updating, and deleting individual
          books. Finally, we define URLs for our views.</p
        >
        <p
          >Using DRF, you can build APIs that support a wide range of HTTP
          methods, authentication mechanisms, and data formats. DRF also
          provides support for API versioning, documentation, and testing,
          making it a powerful tool for building robust APIs in Django.</p
        >
      </article>
      <article>
        <h2>Getting Ready to Deploy Django Application</h2>
        <p
          >Once you have developed your Django application, you need to deploy
          it to a production server. Here are some steps you should take to
          prepare your application for deployment:</p
        >
        <h3>1. Update your settings</h3>
        <p
          >Before deploying your application, you need to update your settings
          file to include production-specific configurations, such as database
          settings, static file settings, and security settings. Make sure to
          keep your secret key and other sensitive information in a separate
          file or environment variable that is not included in your code
          repository.</p
        >
        <h3>2. Collect static files</h3>
        <p
          >If your application uses static files, such as CSS, JavaScript, and
          images, you need to collect them into a single directory that can be
          served by your web server. You can do this using the collectstatic
          command:</p
        >
        <pre
          class="language-python"
        ><code>python manage.py collectstatic</code></pre>
        <h3>3. Test your application</h3>
        <p
          >Before deploying your application to a production server, you should
          test it on a staging server or a local development environment. Make
          sure that your application works as expected and there are no errors
          or security vulnerabilities.</p
        >
        <h3>4. Choose a hosting provider</h3>
        <p
          >Once you are ready to deploy your application, you need to choose a
          hosting provider that meets your requirements for performance,
          reliability, and cost. Popular hosting providers for Django
          applications include Heroku, AWS, DigitalOcean, and Google Cloud
          Platform.</p
        >
        <h3>5. Set up your server</h3>
        <p
          >After choosing a hosting provider, you need to set up your server
          environment, including installing dependencies, configuring your web
          server, and setting up a database. Make sure to follow best practices
          for server security, such as disabling root login, configuring a
          firewall, and using HTTPS for all communication.</p
        >
        <h3>6. Deploy your application</h3>
        <p
          >Finally, you can deploy your application to your production server
          using a deployment tool such as Fabric or Ansible, or by using a
          continuous integration tool such as Jenkins or Travis CI. Make sure to
          monitor your application for errors and performance issues, and to
          follow best practices for server maintenance and backup.</p
        >
      </article>
      <h2 class="a-main-topic">13 Machine Learning with Python</h2>
      <article>
        <h2>01- What is Machine Learning</h2>
        <p
          >Machine Learning is a subset of Artificial Intelligence (AI) that
          allows a system to learn from data without being explicitly
          programmed. In other words, it provides the ability for computers to
          learn and make predictions or decisions based on data.</p
        >
        <p>There are three types of Machine Learning:</p>
        <ol>
          <li
            >Supervised Learning: In this type of Machine Learning, the model is
            trained using labeled data. The algorithm learns from this labeled
            data and then predicts outcomes for new, unseen data.</li
          >
          <li
            >Unsupervised Learning: In this type of Machine Learning, the model
            is trained on unlabeled data. The algorithm learns patterns in the
            data without any guidance and identifies clusters or groups of data
            points with similar characteristics.</li
          >
          <li
            >Reinforcement Learning: In this type of Machine Learning, the
            algorithm learns through trial and error. It interacts with an
            environment and learns through feedback in the form of rewards or
            penalties.</li
          >
        </ol>
        <p
          >Python provides several libraries for Machine Learning, such as
          scikit-learn, TensorFlow, and Keras. Let's take a look at a simple
          example of using scikit-learn for supervised learning:</p
        >
        <pre class="language-python">
<code>from sklearn import datasets
        from sklearn.model_selection import train_test_split
        from sklearn.neighbors import KNeighborsClassifier
        # Load the iris dataset
        iris = datasets.load_iris()
        X = iris.data
        y = iris.target
        
        # Split the dataset into training and testing sets
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)
        
        # Create a KNN classifier with k=3
        knn = KNeighborsClassifier(n_neighbors=3)
        
        # Train the classifier on the training set
        knn.fit(X_train, y_train)
        
        # Test the classifier on the testing set
        y_pred = knn.predict(X_test)
        
        # Print the accuracy of the classifier
        print("Accuracy:", knn.score(X_test, y_test))</code></pre>

        <p
          >In this example, we loaded the iris dataset, split it into training
          and testing sets, created a KNN classifier with k=3, trained the
          classifier on the training set, tested it on the testing set, and
          printed the accuracy of the classifier.</p
        >
      </article>
      <article>
        <h2>02- Machine Learning in Action</h2>
        <p
          >Machine Learning can be applied in various fields such as finance,
          healthcare, e-commerce, and many others. Let's take a look at a simple
          example of using Machine Learning in action for predicting the price
          of a house.</p
        >
        <p
          >For this example, we will be using the Boston Housing Dataset from
          scikit-learn. The dataset contains information about various factors
          that can affect the price of a house such as the number of rooms,
          crime rate, and accessibility to highways. We will be using the linear
          regression algorithm to predict the price of the house based on these
          factors.</p
        >
        <pre
          class="language-python"
        ><code>from sklearn.datasets import load_boston
        from sklearn.linear_model import LinearRegression
        from sklearn.metrics import mean_squared_error, r2_score
        import numpy as np
        # Load the boston dataset
        boston = load_boston()
        
        # Split the dataset into features and target
        X = boston.data
        y = boston.target
        
        # Split the dataset into training and testing sets
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)
        
        # Create a Linear Regression model
        model = LinearRegression()
        
        # Train the model on the training set
        model.fit(X_train, y_train)
        
        # Predict the prices of the houses in the testing set
        y_pred = model.predict(X_test)
        
        # Calculate the mean squared error and the coefficient of determination (R-squared)
        mse = mean_squared_error(y_test, y_pred)
        r2 = r2_score(y_test, y_pred)
        
        # Print the results
        print("Mean squared error:", mse)
        print("Coefficient of determination:", r2)</code></pre>

        <p
          >In this example, we loaded the Boston Housing Dataset, split it into
          training and testing sets, created a linear regression model, trained
          the model on the training set, predicted the prices of the houses in
          the testing set, and calculated the mean squared error and the
          coefficient of determination (R-squared) for the model.</p
        >
        <p
          >Machine Learning is a vast field with a lot of applications. With the
          help of Python and its various libraries, we can easily implement
          Machine Learning algorithms and use them in real-world scenarios.</p
        >
      </article>
      <article>
        <h2>03- Libraries and Tools</h2>
        <p
          >Python has a vast array of libraries and tools for implementing
          Machine Learning algorithms. Let's take a look at some of the popular
          ones:</p
        >
        <ol>
          <li
            ><b>NumPy</b> - NumPy is a library for working with arrays and
            matrices in Python. It provides functions for mathematical
            operations such as addition, subtraction, multiplication, and
            division. NumPy is commonly used in Machine Learning for performing
            linear algebra operations and data manipulation.</li
          >
          <li
            ><b>Pandas</b> - Pandas is a library for data manipulation and
            analysis. It provides functions for importing and exporting data
            from various file formats such as CSV, Excel, and SQL databases.
            Pandas is commonly used in Machine Learning for data preprocessing
            and cleaning.</li
          >
          <li
            ><b>Scikit-learn</b> - Scikit-learn is a library for Machine
            Learning algorithms. It provides functions for regression,
            classification, clustering, and dimensionality reduction.
            Scikit-learn is a popular choice for beginners due to its
            easy-to-use interface and extensive documentation.</li
          >
          <li
            ><b>Keras</b> - Keras is a high-level neural networks API for
            Python. It provides a simple and intuitive interface for building
            neural networks. Keras is commonly used for deep learning
            applications such as image and speech recognition.</li
          >
          <li
            ><b>TensorFlow</b> - TensorFlow is an open-source Machine Learning
            library developed by Google. It provides functions for building and
            training neural networks. TensorFlow is commonly used for deep
            learning applications such as natural language processing and
            computer vision.</li
          >
          <li
            ><b>PyTorch</b> - PyTorch is an open-source Machine Learning library
            developed by Facebook. It provides functions for building and
            training neural networks. PyTorch is commonly used for deep learning
            applications such as natural language processing and computer
            vision.</li
          >
        </ol>
        <p
          >These are just a few examples of the popular libraries and tools used
          in Python for Machine Learning. Depending on the specific requirements
          of your project, you may need to use additional libraries and
          tools.</p
        >
        <p
          >By utilizing these libraries and tools, we can save a lot of time and
          effort in implementing Machine Learning algorithms and focus on
          developing innovative solutions.</p
        >
      </article>
      <article>
        <h2>04- Importing a Data Set</h2>
        <p
          >Before we start building Machine Learning models, we need to import
          the data set into our Python environment. In this example, we will use
          the Pandas library to import a CSV file.</p
        >
        <p
          >Let's assume we have a CSV file named "data.csv" containing
          information about customers. The first step is to import the Pandas
          library and use the read_csv function to import the data:</p
        >
        <pre class="language-python">
<code>import pandas as pd
        
        data = pd.read_csv("data.csv")
        print(data.head())</code></pre>
        <p
          >The <code>read_csv</code> function reads the CSV file and stores it
          in a Pandas DataFrame. The <code>head</code> function is used to
          display the first five rows of the DataFrame.</p
        >
        <p
          >If the CSV file has a different delimiter, such as a tab or
          semicolon, we can specify it using the
          <code>delimiter</code> parameter:</p
        >
        <pre
          class="language-python"
        ><code>data = pd.read_csv("data.csv", delimiter="\t")
        print(data.head())</code></pre>
        <p
          >If the CSV file has missing or null values, we can specify how to
          handle them using the <code>na_values</code> parameter:</p
        >
        <pre
          class="language-python"
        ><code>data = pd.read_csv("data.csv", na_values=["", "NA", "N/A"])
        print(data.head())</code></pre>
        <p
          >By importing the data set into a Pandas DataFrame, we can easily
          manipulate and clean the data before feeding it into our Machine
          Learning models.</p
        >
      </article>
      <article>
        <h2>05- Jupyter Shortcuts</h2>
        <p
          >Jupyter Notebook is a popular environment for writing Python code and
          documenting data analysis. Here are some useful shortcuts for Jupyter
          Notebook:</p
        >
        <ol>
          <li
            ><b>Shift + Enter</b> - Run the current cell and move to the next
            cell.</li
          >
          <li
            ><b>Ctrl + Enter</b> - Run the current cell and stay on the same
            cell.</li
          >
          <li><b>Esc</b> - Switch to command mode.</li>
          <li><b>Enter</b> - Switch to edit mode.</li>
          <li><b>Ctrl + S</b> - Save the notebook.</li>
          <li><b>Ctrl + Z</b> - Undo the last cell deletion or change.</li>
          <li><b>B</b> - Insert a new cell below the current cell.</li>
          <li><b>A</b> - Insert a new cell above the current cell.</li>
          <li><b>D, D</b> - Delete the current cell.</li>
          <li><b>Shift + M</b> - Merge the selected cells.</li>
          <li
            ><b>Shift + Tab</b> - Show the documentation for the selected
            function.</li
          >
          <li><b>Tab</b> - Autocomplete the current function or variable.</li>
        </ol>
        <p
          >These shortcuts can save a lot of time and improve efficiency when
          working with Jupyter Notebook. It's recommended to practice and become
          familiar with these shortcuts to improve productivity.</p
        >
      </article>
      <article>
        <h2>06- A Real Machine Learning Problem</h2>
        <p
          >Let's take a look at a real-world machine learning problem:
          predicting whether a customer will churn (i.e., stop using) a
          telecommunications service. The problem can be framed as a binary
          classification task, where the goal is to predict whether a customer
          will churn (1) or not (0) based on a set of features.</p
        >
        <p>First, we need to import the necessary libraries:</p>
        <pre class="language-python">
<code>import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns</code></pre>
        <p
          >Next, we need to import the data set. The data set can be found in a
          CSV file named "telecom_churn.csv". We can use the Pandas library to
          read the CSV file and store the data in a Pandas DataFrame:</p
        >
        <pre
          class="language-python"
        ><code>data = pd.read_csv("telecom_churn.csv")
print(data.head())</code></pre>
        <p
          >The <code>head()</code> function is used to display the first few
          rows of the DataFrame to ensure that the data is imported
          correctly.</p
        >
        <p
          >After importing the data, we can perform exploratory data analysis
          (EDA) to gain insights into the data and identify any patterns or
          trends. EDA can also help us identify any missing or null values in
          the data. We can use libraries such as Matplotlib and Seaborn to
          visualize the data:</p
        >
        <pre class="language-python">
<code># Distribution of churned customers
sns.countplot(x="Churn", data=data)

# Distribution of customer tenure
sns.histplot(x="tenure", data=data, bins=30)

# Correlation matrix
corr = data.corr()
sns.heatmap(corr, cmap="coolwarm", annot=True)</code></pre>
        <p
          >These visualizations can give us an idea of which features may be
          important in predicting churn, as well as any correlations between
          features. We can also use feature engineering techniques to create new
          features that may improve the performance of our models.</p
        >
        <p
          >Finally, we can use machine learning algorithms to train and evaluate
          our models. We can split the data into training and testing sets using
          libraries such as Scikit-learn:</p
        >
        <pre
          class="language-python"
        ><code>from sklearn.model_selection import train_test_split

X = data.drop("Churn", axis=1)
y = data["Churn"]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</code></pre>
        <p
          >Once we have split the data, we can use various algorithms such as
          logistic regression, decision trees, or random forests to train our
          models and make predictions.</p
        >
        <p
          >This real machine learning problem demonstrates the entire process of
          building a machine learning model, from importing the data to training
          and evaluating the model.
        </p>
      </article>
      <article>
        <h2>07- Preparing the Data</h2>
        <p
          >Before training a machine learning model, it is essential to prepare
          the data appropriately. Data preparation involves cleaning,
          transforming, and pre-processing the data to make it suitable for
          machine learning algorithms. In this note, we will discuss some common
          data preparation techniques.</p
        >
        <p
          ><strong>Handling Missing Data:</strong> Missing data is a common
          problem in real-world datasets, and machine learning algorithms cannot
          handle missing values. We can either remove the rows or columns that
          contain missing values or impute (i.e., fill in) the missing values
          using techniques such as mean, median, or mode imputation.</p
        >
        <pre class="language-python">
<code># Dropping rows with missing values
data.dropna(inplace=True)

# Filling in missing values with mean
data.fillna(data.mean(), inplace=True)</code></pre>
        <p
          ><strong>Encoding Categorical Variables:</strong> Machine learning
          algorithms can only handle numerical data, so we need to encode
          categorical variables. One-hot encoding is a popular technique that
          creates binary columns for each category in a categorical variable.</p
        >
        <pre class="language-python">
<code># One-hot encoding
data_encoded = pd.get_dummies(data, columns=["Gender", "City"], drop_first=True)</code></pre>
        <p
          ><strong>Scaling Numerical Variables:</strong> Scaling is essential
          when the features have different scales. Scaling ensures that all
          features are in the same range and avoids the dominance of one feature
          over another.</p
        >
        <pre
          class="language-python"
        ><code>from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
scaled_data = scaler.fit_transform(data_encoded)</code></pre>
        <p
          ><strong>Feature Selection:</strong> Feature selection involves
          selecting a subset of relevant features for training the machine
          learning model. Feature selection can improve the model's performance,
          reduce overfitting, and reduce the computational cost.</p
        >
        <pre
          class="language-python"
        ><code>from sklearn.feature_selection import SelectKBest, chi2

X = scaled_data[:, :-1]
y = scaled_data[:, -1]

# Feature selection using chi-squared test
k_best = SelectKBest(chi2, k=10)
X_new = k_best.fit_transform(X, y)</code></pre>
        <p
          >Data preparation is an essential step in building machine learning
          models. These techniques help to ensure that the data is clean,
          transformed, and pre-processed in a way that is suitable for machine
          learning algorithms.</p
        >
      </article>
      <article>
        <h2>08- Learning and Predicting</h2>
        <p
          >In machine learning, learning refers to the process of training a
          model on a dataset to make predictions. In this note, we will discuss
          the basic steps involved in the learning and prediction process.</p
        >
        <p
          ><strong>Splitting the Data:</strong> The first step in the learning
          process is to split the dataset into a training set and a test set.
          The training set is used to train the model, and the test set is used
          to evaluate the model's performance. A common splitting ratio is
          80:20, where 80% of the data is used for training and 20% is used for
          testing.</p
        >
        <pre
          class="language-python"
        ><code>from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</code></pre>
        <p
          ><strong>Training the Model:</strong> Once the data is split, the next
          step is to train the machine learning model on the training data. The
          choice of model depends on the problem at hand and the type of data.
          In this example, we will use a logistic regression model.</p
        >
        <pre
          class="language-python"
        ><code>from sklearn.linear_model import LogisticRegression

# Create a logistic regression model
model = LogisticRegression()

# Fit the model to the training data
model.fit(X_train, y_train)</code></pre>
        <p
          ><strong>Making Predictions:</strong> Once the model is trained, we
          can use it to make predictions on new data. In this example, we will
          use the test set to evaluate the model's performance.</p
        >
        <pre class="language-python">
<code># Make predictions on the test set
y_pred = model.predict(X_test)

# Evaluate the model's performance
from sklearn.metrics import accuracy_score

accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)</code></pre>
        <p
          >The accuracy score is a measure of how well the model is performing.
          It is the ratio of the number of correctly predicted instances to the
          total number of instances.</p
        >
        <p
          >The learning and prediction process is a crucial step in machine
          learning. By splitting the data, training the model, and making
          predictions, we can build models that can make accurate predictions on
          new data.</p
        >
      </article>
      <article>
        <h2>09- Calculating the Accuracy</h2>
        <p
          >Accuracy is a metric that is commonly used to evaluate the
          performance of a machine learning model. It measures the percentage of
          correctly classified instances out of the total number of
          instances.</p
        >
        <p
          >In this note, we will show how to calculate the accuracy of a machine
          learning model using Python.</p
        >
        <p
          >First, we need to import the necessary libraries and load the data.
          In this example, we will use the breast cancer dataset from
          scikit-learn.</p
        >
        <pre
          class="language-python"
        ><code>from sklearn.datasets import load_breast_cancer
        from sklearn.model_selection import train_test_split
        from sklearn.linear_model import LogisticRegression
        from sklearn.metrics import accuracy_score
        
        # Load the breast cancer dataset
        data = load_breast_cancer()
        
        # Split the data into training and testing sets
        X_train, X_test, y_train, y_test = train_test_split(data.data, data.target, test_size=0.2, random_state=42)
        
        # Create a logistic regression model
        model = LogisticRegression()
        
        # Fit the model to the training data
        model.fit(X_train, y_train)
        
        # Make predictions on the test set
        y_pred = model.predict(X_test)
        
        # Calculate the accuracy of the model
        accuracy = accuracy_score(y_test, y_pred)
        
        print("Accuracy:", accuracy)</code></pre>
        <p
          >The output will be the accuracy of the model, which is a number
          between 0 and 1. A higher accuracy score indicates better
          performance.</p
        >
        <p
          >Calculating the accuracy of a machine learning model is an essential
          step in evaluating its performance. By comparing the accuracy scores
          of different models, we can choose the best one for our problem.</p
        >
      </article>
      <article>
        <h2>10- Persisting Models</h2>
        <p
          >Once we have trained a machine learning model, we may want to save it
          for future use. This process is known as model persistence.</p
        >
        <p
          >In this note, we will show how to persist a machine learning model
          using Python's joblib library.</p
        >
        <p
          >First, we need to import the necessary libraries and load the data.
          In this example, we will use the iris dataset from scikit-learn.</p
        >
        <pre
          class="language-python"
        ><code>from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score
from joblib import dump, load

# Load the iris dataset
data = load_iris()

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(data.data, data.target, test_size=0.2, random_state=42)

# Create a decision tree classifier
model = DecisionTreeClassifier()

# Fit the model to the training data
model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Calculate the accuracy of the model
accuracy = accuracy_score(y_test, y_pred)

print("Accuracy:", accuracy)

# Save the model to a file
dump(model, 'model.joblib')</code></pre>
        <p
          >The joblib.dump() function saves the trained model to a file named
          "model.joblib".</p
        >
        <p
          >Now, we can load the saved model from the file and use it for
          prediction:</p
        >
        <pre class="language-python">
<code># Load the model from the file
loaded_model = load('model.joblib')

# Make predictions using the loaded model
y_pred = loaded_model.predict(X_test)

# Calculate the accuracy of the loaded model
accuracy = accuracy_score(y_test, y_pred)

print("Accuracy of loaded model:", accuracy)</code></pre>
        <p
          >The output will be the accuracy of the loaded model, which should be
          the same as the accuracy of the original model.</p
        >
        <p
          >Persisting a machine learning model allows us to reuse it without
          having to retrain it every time. This can save time and resources,
          especially for large models or datasets.</p
        >
      </article>

      <article>
        <h2>11- Visualizing a Decision Tree</h2>
        <p
          >Decision trees are a popular machine learning algorithm that are
          often used for classification and regression tasks. They are easy to
          understand and interpret, and can be visualized using Python's
          graphviz library.</p
        >
        <p
          >In this note, we will show how to create and visualize a decision
          tree using scikit-learn and graphviz.</p
        >
        <p
          >First, we need to import the necessary libraries and load the data.
          In this example, we will use the iris dataset from scikit-learn.</p
        >
        <pre
          class="language-python"
        ><code>from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier, plot_tree
import matplotlib.pyplot as plt

# Load the iris dataset
data = load_iris()

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(data.data, data.target, test_size=0.2, random_state=42)

# Create a decision tree classifier
model = DecisionTreeClassifier()

# Fit the model to the training data
model.fit(X_train, y_train)

# Visualize the decision tree
plt.figure(figsize=(20,10))
plot_tree(model, filled=True)
plt.show()</code></pre>
        <p
          >The plot_tree() function generates a visual representation of the
          decision tree. The filled parameter fills the nodes with colors to
          indicate the majority class for classification tasks.</p
        >
        <p
          >The resulting plot should show a decision tree with nodes, branches,
          and leaves that correspond to the decision rules and outcomes of the
          model.</p
        >
        <p
          >Visualizing a decision tree can help us understand how the model
          makes predictions and identify important features in the dataset. It
          can also be useful for explaining the model to others who may not be
          familiar with machine learning.</p
        >
      </article>
    </div>

    <script src="../script.js"></script>
    <script src="../prism.js"></script>
  </body>
</html>
